// Generated by CoffeeScript 2.3.2
(function() {
  var SyncTubeClient, SyncTubeClient_ClipboardPoll, SyncTubeClient_CommandBar, SyncTubeClient_History, SyncTubeClient_Player_HtmlFrame, SyncTubeClient_Player_HtmlImage, SyncTubeClient_Player_HtmlVideo, SyncTubeClient_Player_StuiBanned, SyncTubeClient_Player_StuiCreateForm, SyncTubeClient_Player_StuiKicked, SyncTubeClient_Player_Youtube, ref;

  window.SyncTubeClient_ClipboardPoll = SyncTubeClient_ClipboardPoll = class SyncTubeClient_ClipboardPoll {
    constructor(client1, opts = {}) {
      var base, base1;
      this.client = client1;
      this.opts = opts;
      if ((base = this.opts).pollrate == null) {
        base.pollrate = 1000;
      }
      if ((base1 = this.opts).autostartIfGranted == null) {
        base1.autostartIfGranted = true;
      }
      this.running = false;
      this.lastValue = null;
      this.detectAutostart();
    }

    detectAutostart() {
      return navigator.permissions.query({
        name: 'clipboard-read'
      }).then((status) => {
        if (this.opts.autostartIfGranted && status.state === "granted") {
          this.start();
        }
        return status.onchange = () => {
          if (status.state === "granted") {
            return this.start();
          } else {
            return this.stop();
          }
        };
      });
    }

    start() {
      this.run = true;
      this.client.debug("Started clipboard polling");
      return this.tick();
    }

    async stop(wait = true) {
      var promise;
      this.run = false;
      this.client.debug("Stopping clipboard polling...");
      promise = new Promise((resolve, reject) => {
        return this.stopped = resolve;
      });
      if (!this.running) {
        this.stopped();
      }
      if (wait) {
        await promise;
        this.client.debug("Stopped clipboard polling");
      }
      return promise;
    }

    async tick() {
      var err, text;
      if (!this.run) {
        this.running = false;
        if (typeof this.stopped === "function") {
          this.stopped();
        }
        return;
      }
      this.running = true;
      try {
        text = (await navigator.clipboard.readText());
        if (text !== this.lastValue) {
          this.process(text);
          return this.lastValue = text;
        }
      } catch (error1) {
        err = error1;
      } finally {
        // nothing we can do about it :D
        setTimeout((() => {
          return this.tick();
        }), this.opts.pollrate);
      }
    }

    process(val) {
      return this.client.debug("Processing", val);
    }

  };

  window.SyncTubeClient_ClipboardPoll.start = function() {
    return this.clipboardPoll = new SyncTubeClient_ClipboardPoll(this, this.opts.clipboardPoll);
  };

  window.SyncTubeClient_CommandBar = SyncTubeClient_CommandBar = class SyncTubeClient_CommandBar {
    constructor(client1, opts = {}) {
      this.client = client1;
      this.opts = opts;
      this.buildDom();
      this.captureInput();
    }

    captureInput() {
      return $(document).on("keydown keypress keyup", function(ev) {
        return $("[data-alt-class]").each(function(i, el) {
          if (ev.altKey && !$(el).data("isAlted")) {
            $(el).attr("data-was-class", $(el).attr("class"));
            $(el).attr("class", $(el).data("altClass"));
            return $(el).data("isAlted", true);
          } else if (!ev.altKey && $(el).data("isAlted")) {
            $(el).attr("class", $(el).attr("data-was-class"));
            $(el).removeAttr("data-was-class");
            return $(el).data("isAlted", false);
          }
        });
      });
    }

    updateDesired(data) {
      if (data.state === "play") {
        $("#command_bar [data-command=toggle]").removeClass("btn-success").addClass("btn-warning");
        $("#command_bar [data-command=toggle] i").removeClass("fa-play").addClass("fa-pause");
      } else {
        $("#command_bar [data-command=toggle]").removeClass("btn-warning").addClass("btn-success");
        $("#command_bar [data-command=toggle] i").removeClass("fa-pause").addClass("fa-play");
      }
      if (data.loop) {
        $("#command_bar [data-command='loop toggle']").addClass("btn-warning");
        return $("#command_bar [data-command='loop toggle'] i + i").removeClass("fa-toggle-off").addClass("fa-toggle-on");
      } else {
        $("#command_bar [data-command='loop toggle']").removeClass("btn-warning");
        return $("#command_bar [data-command='loop toggle'] i + i").removeClass("fa-toggle-on").addClass("fa-toggle-off");
      }
    }

    buildDom() {
      return $("#second_row").prepend("<div class=\"col col-12\" id=\"command_bar\" style=\"margin-top: 10px; margin-bottom: -5px; opacity: 0.8; display: none; z-index: 999\">\n  <div class=\"btn-group btn-group-sm\">\n    <button type=\"button\" data-command=\"seek 0\" title=\"start from 0\" class=\"btn btn-secondary\"><i class=\"fa fa-step-backward\"></i></button>\n    <button type=\"button\" data-command=\"seek -60\" data-alt-command=\"seek --slowmo -60\" title=\"go back(+alt=slowmo) 60 seconds\" class=\"btn btn-secondary\"><i class=\"fa fa-fw fa-backward\" data-alt-class=\"fa fa-fw fa-history\"></i> <small>60</small></button>\n    <button type=\"button\" data-command=\"seek -30\" data-alt-command=\"seek --slowmo -30\" title=\"go back(+alt=slowmo) 30 seconds\" class=\"btn btn-secondary\"><i class=\"fa fa-fw fa-backward\" data-alt-class=\"fa fa-fw fa-history\"></i> <small>30</small></button>\n    <button type=\"button\" data-command=\"seek -10\" data-alt-command=\"seek --slowmo -10\" title=\"go back(+alt=slowmo) 10 seconds\" class=\"btn btn-secondary\"><i class=\"fa fa-fw fa-backward\" data-alt-class=\"fa fa-fw fa-history\"></i> <small>10</small></button>\n  </div>\n\n  <button type=\"button\" data-command=\"toggle\" class=\"btn btn-sm btn-success\" style=\"padding-left: 15px; padding-right: 15px\"><i class=\"fa fa-fw fa-play\"></i></button>\n\n  <div class=\"btn-group btn-group-sm\">\n    <button type=\"button\" data-command=\"seek +10\" title=\"go forward 60 seconds\" class=\"btn btn-secondary\"><i class=\"fa fa-forward\"></i> <small>10</small></button>\n    <button type=\"button\" data-command=\"next\" title=\"next in playlist\" class=\"btn btn-info\" style=\"display: none\"><i class=\"fa fa-step-forward\"></i></button>\n    <button type=\"button\" data-command=\"seek +30\" title=\"go forward 30 seconds\" class=\"btn btn-secondary\"><i class=\"fa fa-forward\"></i> <small>30</small></button>\n    <button type=\"button\" data-command=\"seek +60\" title=\"go forward 10 seconds\" class=\"btn btn-secondary\"><i class=\"fa fa-forward\"></i> <small>60</small></button>\n  </div>\n\n  <button title=\"toggle loop\" type=\"button\" data-command=\"loop toggle\" class=\"btn btn-secondary btn-sm\"><i class=\"fa fa-refresh\"></i> <i class=\"fa fa-toggle-on\"></i></button>\n\n\n  <div class=\"btn-group btn-group-sm\">\n    <button type=\"button\" class=\"btn btn-primary\" data-suggest-command=\"play \" data-alt-command=\"play -n \" title=\"add YT\"><i class=\"fa fa-plus\"></i> <i class=\"fa fa-youtube\"></i></button>\n    <button type=\"button\" class=\"btn btn-primary dropdown-toggle dropdown-toggle-split\" data-toggle=\"dropdown\"></button>\n    <div class=\"dropdown-menu\">\n      <a href=\"#\" class=\"dropdown-item\" data-suggest-command=\"video \" data-alt-command=\"video -n \"><i class=\"fa fa-fw fa-file-video-o\"></i> generic video (e.g. mp4)</a>\n      <a href=\"#\" class=\"dropdown-item\" data-suggest-command=\"image \" data-alt-command=\"image -n \"><i class=\"fa fa-fw fa-picture-o\"></i> image</a>\n      <a href=\"#\" class=\"dropdown-item\" data-suggest-command=\"browse \" data-alt-command=\"browse -n \"><i class=\"fa fa-fw fa-globe\"></i> browse URL</a>\n    </div>\n  </div>\n</div>");
    }

    show() {
      return $("#command_bar").show(200, function() {
        return $(window).resize();
      });
    }

    hide() {
      return $("#command_bar").hide(200, function() {
        return $(window).resize();
      });
    }

  };

  window.SyncTubeClient_CommandBar.start = function() {
    return this.commandBar = new SyncTubeClient_CommandBar(this, this.opts.command_bar);
  };

  window.SyncTubeClient_ControlCodes = {
    CMD_server_settings: function(data) {
      var k, results, v;
      results = [];
      for (k in data) {
        v = data[k];
        if (!(k !== "type")) {
          continue;
        }
        this.debug("Accepting server controlled setting", k, "was", this.opts.synced[k], "new", v);
        results.push(this.opts.synced[k] = v);
      }
      return results;
    },
    CMD_ack: function() {
      return this.enableInput();
    },
    CMD_session_kicked: function(info) {
      this.CMD_disconnected();
      return this.CMD_desired({
        ctype: "StuiKicked",
        info: info
      });
    },
    CMD_banned: function(info) {
      this.CMD_disconnected();
      return this.CMD_desired({
        ctype: "StuiBanned",
        info: info
      });
    },
    CMD_kicked: function(info) {
      return this.CMD_desired({
        ctype: "StuiKicked",
        info: info
      });
    },
    CMD_disconnected: function(...a) {
      this.CMD_unsubscribe();
      this.CMD_lost_control();
      return this.reconnect = false;
    },
    CMD_taken_control: function() {
      var ref;
      this.control = true;
      return (ref = this.commandBar) != null ? ref.show() : void 0;
    },
    CMD_lost_control: function() {
      var ref;
      this.control = false;
      return (ref = this.commandBar) != null ? ref.hide() : void 0;
    },
    CMD_taken_host: function() {
      return this.host = true;
    },
    CMD_lost_host: function() {
      return this.host = false;
    },
    CMD_unsubscribe: function() {
      this.CMD_ui_clear({
        component: "clients"
      });
      this.CMD_ui_clear({
        component: "playlist"
      });
      this.CMD_video_action({
        action: "destroy"
      });
      return this.playlist.hide();
    },
    CMD_desired: function(data) {
      var e, klass, ref, ref1;
      if (data.ctype !== ((ref = this.player) != null ? ref.ctype : void 0)) {
        this.CMD_video_action({
          action: "destroy"
        });
        klass = `SyncTubeClient_Player_${data.ctype}`;
        try {
          this.player = new window[klass](this);
        } catch (error1) {
          e = error1;
          this.addError(`Failed to load player ${data.ctype}! ${e.toString().replace("window[klass]", klass)}`);
          throw e;
          return;
        }
      }
      this.player.updateDesired(data);
      return (ref1 = this.commandBar) != null ? ref1.updateDesired(data) : void 0;
    },
    CMD_ui_clear: function(data) {
      switch (data.component) {
        case "chat":
          return this.content.html("");
        case "clients":
          return this.clients.html("");
        case "playlist":
          return this.playlist.html("");
        case "player":
          return this.CMD_video_action({
            action: "destroy"
          });
      }
    },
    CMD_ui_clipboard_poll: function(data) {
      if (data.action === "permission") {
        return navigator.clipboard.readText();
      }
    },
    CMD_ui_chat_show: function(data) {
      return this.content.show(200, () => {
        return this.content.scrollTop(this.content.prop("scrollHeight"));
      });
    },
    CMD_ui_chat_hide: function(data) {
      return this.content.hide(200);
    },
    CMD_ui_chat_toggle: function(data) {
      return this.content.toggle(200, () => {
        return this.content.scrollTop(this.content.prop("scrollHeight"));
      });
    },
    CMD_ui_playlist_show: function(data) {
      this.playlist.removeClass("collapsed");
      return this.delay(200, function() {
        return $(window).resize();
      });
    },
    CMD_ui_playlist_hide: function(data) {
      this.playlist.addClass("collapsed");
      return this.delay(200, function() {
        return $(window).resize();
      });
    },
    CMD_ui_playlist_toggle: function(data) {
      this.playlist.toggleClass("collapsed");
      return this.delay(200, function() {
        return $(window).resize();
      });
    },
    CMD_video_action: function(data) {
      var ref, ref1, ref2, ref3, ref4;
      switch (data.action) {
        case "resume":
          if (data.cancelPauseEnsured) {
            if ((ref = this.player) != null) {
              if (typeof ref.pauseEnsured === "function") {
                ref.pauseEnsured("server cancel");
              }
            }
          }
          return (ref1 = this.player) != null ? ref1.play() : void 0;
        case "pause":
          return (ref2 = this.player) != null ? ref2.pause() : void 0;
        case "sync":
          return (ref3 = this.player) != null ? ref3.force_resync = true : void 0;
        case "seek":
          return (ref4 = this.player) != null ? ref4.seekTo(data.to, data.paused) : void 0;
        case "destroy":
          this.dontBroadcast = false;
          this.stopBroadcast();
          if (this.player) {
            this.player.destroy();
            this.player = null;
            return this.broadcastState(-666);
          }
      }
    },
    CMD_navigate: function(data) {
      if (data.reload) {
        return window.location.reload();
      } else if (data.location) {
        return window.location.href = data.location;
      }
    },
    CMD_session_index: function(data) {
      return this.index = data.index;
    },
    CMD_require_username: function(data) {
      var hparams, p;
      this.enableInput();
      this.CMD_desired({
        ctype: "StuiCreateForm"
      });
      if (data.maxLength != null) {
        this.input.attr("maxLength", data.maxLength);
      }
      this.status.text("Choose name:");
      // check hash params
      if (data.autofill === false) {
        return;
      }
      hparams = this.getHashParams();
      if (p = hparams.user || hparams.username || hparams.name) {
        return this.connection.send(p);
      }
    },
    CMD_username: function(data) {
      var ch, cmd, hparams, ref;
      this.name = data.username;
      this.input.removeAttr("maxLength");
      this.status.text(`${this.name}:`);
      if ((ref = this.player) != null) {
        if (typeof ref.clientUpdate === "function") {
          ref.clientUpdate();
        }
      }
      // check hash params
      hparams = this.getHashParams();
      if (ch = hparams.channel || hparams.join) {
        this.connection.send(`/join ${ch}`);
      }
      if (hparams.control) {
        cmd = `/control ${hparams.control}`;
        if (hparams.password != null) {
          cmd += ` ${hparams.password}`;
        }
        return this.connection.send(cmd);
      }
    },
    CMD_playlist_single_entry: function(data) {
      var _el, changeAttr, changeHTML, el;
      el = this.playlist.find(`[data-pl-id="${data.id}"]`);
      if (!el.length || el.data("plIndex") !== data.index) {
        _el = $(this.buildPlaylistElement(data));
        _el.attr("data-pl-id", data.id);
        if (el.length) {
          el.replaceWith(_el);
        } else {
          this.playlist.append(_el);
        }
        el = _el;
      }
      changeHTML = function(el, v) {
        if (!el.length) {
          return;
        }
        if (el.html() !== v) {
          el.html(v);
        }
        return el;
      };
      changeAttr = function(el, a, v) {
        if (!el.length) {
          return;
        }
        if (el.attr(a) !== v) {
          el.attr(a, v);
        }
        return el;
      };
      if (data.thumbnail) {
        changeAttr(el.find("[data-attr=thumbnail]"), "src", data.thumbnail);
      }
      if (data.author) {
        changeAttr(el.find("[data-attr=author]"), "href", data.author[1]);
        changeHTML(el.find("[data-attr=author]"), data.author[0]);
      }
      if (typeof data.name === "string") {
        changeHTML(el.find("[data-attr=name]"), data.name);
      } else {
        changeAttr(el.find("[data-attr=name]"), "href", data.name[1]);
        changeHTML(el.find("[data-attr=name]"), data.name[0]);
      }
      changeHTML(el.find("[data-attr=timestamp]"), data.timestamp);
      this.playlist.toggle(!!this.playlist.find("div[data-pl-id]").length);
      this.playlist.scrollTop(this.playlist.find("div.active").prop("offsetTop") - 15);
      return $(window).resize();
    },
    CMD_playlist_update: function(data) {
      var j, len, ple, ref;
      if (data.entries) {
        this.CMD_ui_clear({
          component: "playlist"
        });
        ref = data.entries;
        for (j = 0, len = ref.length; j < len; j++) {
          ple = ref[j];
          this.CMD_playlist_single_entry(ple);
        }
      }
      if (data.index != null) {
        this.playlist.find("div[data-pl-id]").removeClass("active");
        this.playlist.find(`div[data-pl-index=${data.index}]`).addClass("active");
      }
      this.playlist.toggle(!!this.playlist.find("div[data-pl-id]").length);
      this.playlist.scrollTop(this.playlist.find("div.active").prop("offsetTop") - 15);
      return $(window).resize();
    },
    CMD_update_single_subscriber: function(resp) {
      var _el, changeAttr, changeHTML, data, el, k, ref, v;
      data = (resp != null ? resp.data : void 0) || {};
      if (data.index == null) {
        return;
      }
      el = this.clients.find(`[data-client-index=${data.index}]`);
      if (!el.length || data.state.istate === -666) {
        _el = $(this.buildSubscriberElement());
        _el.attr("data-client-index", data.index);
        if (el.length) {
          el.replaceWith(_el);
        } else {
          this.clients.append(_el);
        }
        el = _el;
      }
      changeHTML = function(el, v) {
        if (!el.length) {
          return;
        }
        if (el.html() !== v) {
          el.html(v);
        }
        return el;
      };
      changeAttr = function(el, a, v) {
        if (!el.length) {
          return;
        }
        if (el.attr(a) !== v) {
          el.attr(a, v);
        }
        return el;
      };
      for (k in data) {
        v = data[k];
        changeHTML(el.find(`[data-attr=${k}]`), "" + v);
      }
      ref = data.state;
      for (k in ref) {
        v = ref[k];
        changeHTML(el.find(`[data-attr=${k}]`), "" + v);
      }
      el.find("[data-attr=progress-bar-buffered]").css({
        width: `${(data.state.loaded_fraction || 0) * 100}%`
      });
      el.find("[data-attr=progress-bar-position]").css({
        left: `${(data.state.seek <= 0 ? 0 : data.state.seek / data.state.playtime * 100)}%`
      });
      if (data.icon) {
        changeAttr(el.find("[data-attr=icon-ctn] i"), "class", `fa fa-${data.icon} ${data.icon_class}`);
      }
      if (data.control) {
        changeAttr(el.find("[data-attr=admin-ctn] i"), "class", "fa fa-shield text-info");
        changeAttr(el.find("[data-attr=admin-ctn] i"), "title", "admin");
      }
      if (data.isHost) {
        changeAttr(el.find("[data-attr=admin-ctn] i"), "class", "fa fa-shield text-danger");
        changeAttr(el.find("[data-attr=admin-ctn] i"), "title", "HOST");
      }
      changeAttr(el.find("[data-attr=drift-ctn] i"), "class", `fa fa-${(data.drift ? data.drift > 0 ? "backward" : "forward" : "circle-o-notch")} text-warning`);
      changeHTML(el.find("[data-attr=drift]"), el.find("[data-attr=drift]").html().replace("-", ""));
      if ((this.index != null) && data.index === this.index) {
        return this.drift = parseFloat(data.drift);
      }
    },
    CMD_subscriber_list: function(data) {
      var j, len, ref, results, sub, subs;
      this.clients.html("");
      // get ordered list
      subs = data.subscribers.sort(function(a, b) {
        if (a.isHost && !b.isHost) {
          return -1;
        } else {
          return 1;
        }
      });
      subs = subs.sort(function(a, b) {
        if (a.control && !b.control) {
          return -1;
        } else {
          return 1;
        }
      });
      ref = data.subscribers;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        sub = ref[j];
        results.push(this.CMD_update_single_subscriber({
          data: sub
        }));
      }
      return results;
    }
  };

  window.SyncTubeClient = SyncTubeClient = (function() {
    class SyncTubeClient {
      static include(obj, into) {
        var key, ref, value;
        for (key in obj) {
          value = obj[key];
          if (key !== "included" && key !== "start" && key !== "init") {
            this.prototype[key] = value;
          }
        }
        return (ref = obj.included) != null ? ref.call(this, into) : void 0;
      }

      include(addon) {
        this.included.push(addon);
        return this.constructor.include(addon, this);
      }

      constructor(opts = {}) {
        var base, base1, base2, base3, inc, j, len, ref, ref1;
        this.opts = opts;
        // options
        if ((base = this.opts).debug == null) {
          base.debug = false;
        }
        if (this.opts.debug) {
          window.client = this;
        }
        // synced settings (controlled by server)
        if ((base1 = this.opts).synced == null) {
          base1.synced = {};
        }
        if ((base2 = this.opts.synced).maxDrift == null) {
          base2.maxDrift = 60000; // superseded by server instructions
        }
        if ((base3 = this.opts.synced).packetInterval == null) {
          base3.packetInterval = 10000; // superseded by server instructions
        }
        
        // Client data
        this.index = null;
        this.name = null;
        this.control = false;
        this.host = false;
        this.drift = 0;
        // modules
        this.include(SyncTubeClient_Util);
        this.include(SyncTubeClient_ControlCodes);
        this.include(SyncTubeClient_Network);
        this.include(SyncTubeClient_UI);
        this.include(SyncTubeClient_CommandBar);
        this.include(SyncTubeClient_Player_Youtube);
        this.include(SyncTubeClient_Player_HtmlFrame);
        this.include(SyncTubeClient_Player_HtmlImage);
        this.include(SyncTubeClient_Player_HtmlVideo);
        this.include(SyncTubeClient_History);
        this.include(SyncTubeClient_ClipboardPoll);
        ref = this.included;
        for (j = 0, len = ref.length; j < len; j++) {
          inc = ref[j];
          if ((ref1 = inc.init) != null) {
            ref1.apply(this);
          }
        }
      }

      welcome(done) {
        $("#page").hide();
        return typeof done === "function" ? done() : void 0;
      }

      start() {
        var inc, j, len, ref, ref1;
        ref = this.included;
        for (j = 0, len = ref.length; j < len; j++) {
          inc = ref[j];
          if ((ref1 = inc.start) != null) {
            ref1.apply(this);
          }
        }
        $("#page").css({
          maxWidth: 500,
          opacity: 0
        });
        $("#page").fadeIn(1250);
        this.delay(50, function() {
          return $(window).resize();
        });
        this.delay(2250, function() {
          $("#welcome").hide(750);
          return $("#page").fadeTo(500, 1);
        });
        return this.listen();
      }

      // ===========
      // = Logging =
      // ===========
      debug(...msg) {
        if (!this.opts.debug) {
          return;
        }
        msg.unshift(`[ST ${(new Date).toISOString()}]`);
        return console.debug.apply(this, msg);
      }

      info(...msg) {
        msg.unshift(`[ST ${(new Date).toISOString()}]`);
        return console.log.apply(this, msg);
      }

      warn(...msg) {
        msg.unshift(`[ST ${(new Date).toISOString()}]`);
        return console.warn.apply(this, msg);
      }

      error(...msg) {
        msg.unshift(`[ST ${(new Date).toISOString()}]`);
        return console.error.apply(this, msg);
      }

    };

    SyncTubeClient.prototype.VIEW_COMPONENTS = ["content", "view", "input", "input_nofocus", "status", "queue", "playlist", "clients"];

    SyncTubeClient.prototype.included = [];

    return SyncTubeClient;

  }).call(this);

  window.SyncTubeClient_History = SyncTubeClient_History = class SyncTubeClient_History {
    constructor(client1, opts = {}) {
      var base, base1;
      this.client = client1;
      this.opts = opts;
      if ((base = this.opts).limit == null) {
        base.limit = 100;
      }
      if ((base1 = this.opts).save == null) {
        base1.save = true; // @todo set to false
      }
      this.log = this.opts.save ? this.loadLog() : [];
      this.index = -1;
      this.buffer = null;
      this.captureInput();
    }

    captureInput() {
      return this.client.input.keydown((event) => {
        if (event.keyCode === 27) { // ESC
          if (this.index !== -1) {
            this.index = -1;
            if (this.buffer != null) {
              this.client.input.val(this.buffer);
            }
            this.buffer = null;
          }
          return true;
        }
        if (event.keyCode === 38) { // ArrowUp
          if (this.log[this.index + 1] == null) {
            return false;
          }
          if (this.index === -1) {
            this.buffer = this.client.input.val();
          }
          this.index++;
          this.client.input.val(this.log[this.index]);
          return false;
        }
        if (event.keyCode === 40) { // ArrowDown
          if (this.index === 0) {
            this.index = -1;
            this.restoreBuffer();
            return false;
          }
          if (this.log[this.index - 1] == null) {
            return false;
          }
          this.index--;
          this.client.input.val(this.log[this.index]);
          return false;
        }
        return true;
      });
    }

    restoreBuffer() {
      if (this.buffer != null) {
        this.client.input.val(this.buffer);
      }
      return this.buffer = null;
    }

    append(cmd) {
      if (cmd && (!this.log.length || this.log[0] !== cmd)) {
        this.log.unshift(cmd);
      }
      while (this.log.length > this.opts.limit) {
        this.log.pop();
      }
      if (this.opts.save) {
        this.saveLog();
      }
      this.index = -1;
      return this.buffer = null;
    }

    saveLog() {
      return this.LSsave("client_history", this.log);
    }

    loadLog() {
      return this.LSload("client_history", []);
    }

    LSsave(key, value) {
      return localStorage.setItem(`synctube_${key}`, JSON.stringify(value));
    }

    LSload(key, defVal) {
      var e;
      try {
        return JSON.parse(localStorage.getItem(`synctube_${key}`)) || defVal;
      } catch (error1) {
        e = error1;
        return defVal;
      }
    }

  };

  window.SyncTubeClient_History.start = function() {
    return this.history = new SyncTubeClient_History(this, this.opts.history);
  };

  window.SyncTubeClient_Network = {
    init: function() {
      var base, base1, base2, discoveredHost, discoveredPort, discoveredProtocol;
      discoveredHost = document.location.hostname;
      discoveredPort = document.location.port || (document.location.protocol === "https:" ? 443 : 80);
      discoveredProtocol = document.location.protocol === "https:" ? "wss" : "ws";
      if ((base = this.opts).wsIp == null) {
        base.wsIp = $("meta[name=synctube-server-ip]").attr("content") || discoveredHost;
      }
      if ((base1 = this.opts).wsPort == null) {
        base1.wsPort = $("meta[name=synctube-server-port]").attr("content") || discoveredPort;
      }
      if ((base2 = this.opts).wsProtocol == null) {
        base2.wsProtocol = $("meta[name=synctube-server-protocol]").attr("content") || discoveredProtocol;
      }
      this.dontBroadcast = false;
      return this.reconnect = true;
    },
    start: function() {
      this.openWSconnection();
      return this.detectBrokenConnection();
    },
    openWSconnection: function() {
      var address;
      // mozilla fallback
      window.WebSocket = window.WebSocket || window.MozWebSocket;
      // if browser doesn't support WebSocket, just show some notification and exit
      if (!window.WebSocket) {
        this.content.html($("<p>", {
          text: "Sorry, but your browser doesn't support WebSocket."
        }));
        this.status.hide();
        this.input.hide();
        return;
      }
      // open connection
      address = `${this.opts.wsProtocol}://${this.opts.wsIp}:${this.opts.wsPort}/cable`;
      this.debug(`Opening connection to ${address}`);
      this.connection = new WebSocket(address);
      this.connection.onopen = () => {
        return this.debug("WS connection opened");
      };
      return this.connection.onerror = (error) => {
        this.error("WS connection encountered an error", error);
        return this.content.html($("<p>", {
          text: "Sorry, but there's some problem with your connection or the server is down."
        }));
      };
    },
    detectBrokenConnection: function() {
      return setInterval((() => {
        if (this.connection.readyState !== 1) {
          this.status.text("Error");
          this.disableInput().val("Unable to communicate with the WebSocket server. Please reload!");
          this.dontBroadcast = true;
          return this.delay(1000, () => {
            if (this.reconnect) {
              return window.location.reload();
            }
          });
        }
      }), 3000);
    },
    listen: function() {
      return this.connection.onmessage = (message) => {
        var error, json;
        try {
          json = JSON.parse(message.data);
        } catch (error1) {
          error = error1;
          this.error("Invalid JSON", message.data, error);
          return;
        }
        switch (json.type) {
          case "code":
            //@debug "received CODE", json.data
            if (this[`CMD_${json.data.type}`] != null) {
              return this[`CMD_${json.data.type}`](json.data);
            } else {
              return this.warn(`no client implementation for CMD_${json.data.type}`);
            }
            break;
          case "message":
            //@debug "received MESSAGE", json.data
            return this.addMessage(json.data);
          default:
            return this.warn("Hmm..., I've never seen JSON like this:", json);
        }
      };
    },
    startBroadcast: function() {
      if (this.broadcastStateInterval != null) {
        return;
      }
      return this.broadcastStateInterval = setInterval((() => {
        return this.broadcastState();
      }), this.opts.synced.packetInterval);
    },
    stopBroadcast: function() {
      clearInterval(this.broadcastStateInterval);
      return this.broadcastStateInterval = null;
    },
    sendControl: function(cmd) {
      if (!this.control) {
        return;
      }
      this.debug("send control", cmd);
      return this.connection.send(cmd);
    },
    broadcastState: function(ev = (ref = this.player) != null ? ref.getState() : void 0) {
      var packet, ref1, ref2, ref3, ref4, state;
      if (this.dontBroadcast) {
        return;
      }
      state = (function() {
        switch (ev) {
          case -666:
            return "uninitialized";
          case -1:
            return "unstarted";
          case 0:
            return "ended";
          case 1:
            return "playing";
          case 2:
            return "paused";
          case 3:
            return "buffering";
          case 5:
            return "cued";
          default:
            return "ready";
        }
      })();
      packet = {
        state: state,
        istate: ev,
        seek: (ref1 = this.player) != null ? ref1.getCurrentTime() : void 0,
        playtime: (ref2 = this.player) != null ? ref2.getDuration() : void 0,
        loaded_fraction: (ref3 = this.player) != null ? ref3.getLoadedFraction() : void 0,
        url: (ref4 = this.player) != null ? ref4.getUrl() : void 0
      };
      this.lastPacketSent = new Date;
      return this.connection.send("!packet:" + JSON.stringify(packet));
    }
  };

  window.SyncTubeClient_Player_HtmlFrame = SyncTubeClient_Player_HtmlFrame = (function() {
    class SyncTubeClient_Player_HtmlFrame {
      constructor(client1) {
        this.client = client1;
        this.state = -1;
        this.loaded = 0;
        this.frame = $("<iframe>", {
          id: "view_frame",
          width: "100%",
          height: "100%"
        }).appendTo(this.client.view);
        this.frame.on("load", () => {
          this.state = this.loaded = 1;
          return this.client.broadcastState();
        });
      }

      destroy() {
        return this.frame.remove();
      }

      updateDesired(data) {
        if (data.url !== this.frame.attr("src")) {
          this.loaded = 0;
          this.state = 3;
          this.frame.attr("src", data.url);
          return this.client.broadcastState();
        }
      }

      getUrl() {
        return this.frame.attr("src");
      }

      getState() {
        return this.state;
      }

      getLoadedFraction() {
        return this.loaded;
      }

      // null api functions
      play() {}

      pause() {}

      seekTo(time, paused = false) {}

      getCurrentTime() {}

      getDuration() {}

    };

    SyncTubeClient_Player_HtmlFrame.prototype.ctype = "HtmlFrame";

    return SyncTubeClient_Player_HtmlFrame;

  }).call(this);

  window.SyncTubeClient_Player_HtmlImage = SyncTubeClient_Player_HtmlImage = (function() {
    class SyncTubeClient_Player_HtmlImage {
      constructor(client1) {
        this.client = client1;
        this.state = -1;
        this.loaded = 0;
        this.image = $("<img>", {
          id: "view_image",
          height: "100%"
        }).appendTo(this.client.view);
        this.image.on("load", () => {
          this.state = this.loaded = 1;
          return this.client.broadcastState();
        });
      }

      destroy() {
        return this.image.remove();
      }

      updateDesired(data) {
        if (data.url !== this.image.attr("src")) {
          this.loaded = 0;
          this.state = 3;
          this.image.attr("src", data.url);
          return this.client.broadcastState();
        }
      }

      getUrl() {
        return this.image.attr("src");
      }

      getState() {
        return this.state;
      }

      getLoadedFraction() {
        return this.loaded;
      }

      // null api functions
      play() {}

      pause() {}

      seekTo(time, paused = false) {}

      getCurrentTime() {}

      getDuration() {}

    };

    SyncTubeClient_Player_HtmlImage.prototype.ctype = "HtmlImage";

    return SyncTubeClient_Player_HtmlImage;

  }).call(this);

  window.SyncTubeClient_Player_HtmlVideo = SyncTubeClient_Player_HtmlVideo = (function() {
    class SyncTubeClient_Player_HtmlVideo {
      constructor(client1) {
        this.client = client1;
        this.video = $("<video>", {
          id: "view_video",
          width: "100%",
          height: "100%",
          controls: true
        }).appendTo(this.client.view);
        this.volumeRestored = false;
        // events
        this.video.on("loadeddata", () => {
          var ref1, vol;
          // restore saved volume
          if (this.volumeRestored) {
            return;
          }
          this.volumeRestored = true;
          vol = (ref1 = this.client.history) != null ? ref1.LSload("player_volume") : void 0;
          if (vol != null) {
            this.client.debug(`Restored player volume ${vol / 100}`);
            return this.video.get(0).volume = vol / 100;
          }
        });
        this.video.on("click", () => {
          if (!(this.client.control || !this.everPlayed)) {
            return;
          }
          if (this.getState() === 1) {
            return this.pause();
          } else {
            return this.play();
          }
        });
        //@video.on "canplay", => console.log "canplay", (new Date).toISOString()
        this.video.on("canplaythrough", () => {
          return this.sendReady();
        });
        this.video.on("error", () => {
          return this.error = this.video.get(0).error;
        });
        this.video.on("playing", () => {
          return this.sendResume();
        });
        this.video.on("pause", () => {
          if (this.getCurrentTime() !== this.getDuration()) {
            return this.sendPause();
          }
        });
        this.video.on("timeupdate", () => {
          if (!this.seeking) {
            return this.lastKnownTime = this.getCurrentTime();
          }
        });
        this.video.on("ended", () => {
          if (this.getCurrentTime() === this.getDuration()) {
            return this.sendEnded();
          }
        });
        this.video.on("seeking", () => {
          return this.seeking = true;
        });
        this.video.on("volumechange", () => {
          return this.rememberVolume();
        });
        this.video.on("seeked", (a) => {
          this.seeking = false;
          if (this.systemSeek) {
            return this.systemSeek = false;
          } else {
            return this.sendSeek();
          }
        });
      }

      destroy() {
        this.rememberVolume();
        return this.video.remove();
      }

      updateDesired(data) {
        var lastPacketDiff;
        if (data.state === "play") {
          this.video.attr("autoplay", "autoplay");
        } else {
          this.video.removeAttr("autoplay");
        }
        if (data.url !== this.video.attr("src")) {
          this.client.debug("switching video from", this.getUrl(), "to", data.url);
          this.video.attr("src", data.url);
          this.error = false;
          this.playing = false;
          this.everPlayed = false;
          this.client.startBroadcast();
          this.client.broadcastState();
        }
        if (data.loop) {
          this.video.attr("loop", "loop");
          if (this.getCurrentTime() === this.getDuration() && this.getDuration() > 0) {
            this.play();
          }
        } else {
          this.video.removeAttr("loop");
        }
        if (!this.error && this.getState() === 1 && data.state === "pause") {
          this.client.debug("pausing playback", data.state, data.seek, this.getState());
          this.systemPause = true;
          this.pause();
          this.seekTo(data.seek, true);
          return;
        }
        if (!this.error && this.getState() !== 1 && data.state === "play") {
          lastPacketDiff = this.client.lastPacketSent ? (new Date()) - this.client.lastPacketSent : null;
          if ((lastPacketDiff != null) && lastPacketDiff < 75 && this.getState() === 0) {
            this.client.debug("ignore starting playback, stopped and we just sent packet", lastPacketDiff);
          } else {
            this.client.debug("starting playback, state:", this.getState());
            this.systemResume = true;
            this.play();
          }
        }
        if (Math.abs(this.client.drift * 1000) > this.client.opts.synced.maxDrift || this.force_resync || data.force) {
          this.force_resync = false;
          this.client.debug("seek to correct drift", this.client.drift, data.seek);
          if (!(this.getCurrentTime() === 0 && data.seek === 0)) {
            return this.seekTo(data.seek, true);
          }
        }
      }

      getState() {
        if (this.video.get(0).readyState === 0) {
          // uninitalized
          return -1;
        }
        if (this.video.get(0).readyState === 2 || this.video.get(0).readyState === 3) {
          // buffering
          return 3;
        }
        if (this.getCurrentTime() === this.getDuration() && this.video.get(0).paused) {
          // ended playback
          return 0;
        }
        // paused or playing
        if (this.video.get(0).paused) {
          return 2;
        } else if (this.playing) {
          return 1;
        } else {
          return -1;
        }
      }

      getUrl() {
        return this.video.get(0).currentSrc;
      }

      play() {
        if (this.video.length) {
          return this.video.get(0).play();
        }
      }

      pause() {
        if (this.video.length) {
          return this.video.get(0).pause();
        }
      }

      getCurrentTime() {
        if (this.seeking) {
          return this.lastKnownTime;
        } else {
          return this.video.get(0).currentTime;
        }
      }

      getDuration() {
        if (this.video.get(0).seekable.length) {
          return this.video.get(0).seekable.end(0);
        } else {
          return 0;
        }
      }

      seekTo(time, paused = false) {
        this.systemSeek = true;
        return this.video.get(0).currentTime = time;
      }

      getLoadedFraction() {
        var cur, dur, end, j, maxbuf, n, ref1, start;
        maxbuf = 0;
        cur = this.getCurrentTime();
        dur = this.getDuration();
        if (!dur) {
          return 0;
        }
        for (n = j = 0, ref1 = this.video.get(0).buffered.length; (0 <= ref1 ? j < ref1 : j > ref1); n = 0 <= ref1 ? ++j : --j) {
          start = this.video.get(0).buffered.start(n);
          end = this.video.get(0).buffered.end(n);
          if (cur >= start && cur <= end) {
            maxbuf = end;
            break;
          } else if (end > maxbuf) {
            maxbuf = end;
          }
        }
        return parseFloat(maxbuf) / parseFloat(dur);
      }

      sendSeek(time = this.getCurrentTime()) {
        if (!this.client.dontBroadcast) {
          return this.client.sendControl(`/seek ${time}`);
        }
      }

      sendReady() {
        return this.client.sendControl("/ready");
      }

      sendResume() {
        this.everPlayed = true;
        this.playing = true;
        if (this.systemResume) {
          this.systemResume = false;
        } else {
          if (!this.client.dontBroadcast) {
            this.client.sendControl("/resume");
          }
        }
        return this.client.broadcastState();
      }

      sendPause() {
        this.playing = false;
        if (this.systemPause) {
          this.systemPause = false;
        } else {
          if (!this.client.dontBroadcast) {
            this.client.sendControl("/pause");
          }
        }
        return this.client.broadcastState();
      }

      sendEnded() {
        this.playing = false;
        if (this.everPlayed) {
          return this.client.broadcastState();
        }
      }

      rememberVolume() {
        var ref1, stored, vol;
        if (this.client.history == null) {
          return;
        }
        vol = ((ref1 = this.video.get(0)) != null ? ref1.volume : void 0) * 100;
        stored = this.client.history.LSload("player_volume");
        if ((vol != null) && stored !== vol) {
          this.client.debug(`Remembered player volume ${vol}`);
          return this.client.history.LSsave("player_volume", vol);
        }
      }

    };

    SyncTubeClient_Player_HtmlVideo.prototype.ctype = "HtmlVideo";

    return SyncTubeClient_Player_HtmlVideo;

  }).call(this);

  window.SyncTubeClient_Player_StuiBanned = SyncTubeClient_Player_StuiBanned = (function() {
    class SyncTubeClient_Player_StuiBanned {
      constructor(client1) {
        this.client = client1;
        this.vp = $("<div>", {
          id: "view_stui_banned",
          width: "100%",
          height: "100%"
        }).fadeIn(3000).appendTo(this.client.view);
        this.buildView();
      }

      destroy() {
        return this.vp.remove();
      }

      buildView() {
        return this.vp.append("<div class=\"flexcentered\" style=\"color: rgba(255, 255, 255, 0.88);\">\n  <div style=\"max-width: 800px\">\n    <div class=\"alert alert-danger\">\n      <h1 class=\"alert-heading\"><i class=\"fa fa-warning\"></i> You have been banned!</h1>\n      <big><strong data-reason></strong></big>\n      <big><strong>banned <span data-until></span></strong></big>\n    </div>\n  </div>\n</div>");
      }

      updateDesired(data) {
        var banned_until, reason;
        if (reason = data.info.reason) {
          this.vp.find("[data-reason]").html(`<i class="fa fa-comment fa-flip-horizontal"></i> ${reason}<hr>`);
        }
        if (data.info.banned_until) {
          banned_until = new Date(data.info.banned_until);
          return this.vp.find("[data-until]").html(`until<br>${banned_until.toString()}`);
        } else {
          return this.vp.find("[data-until]").html("permanently");
        }
      }

      // null api functions
      getUrl() {
        return "STUI:CreateForm";
      }

      getState() {
        return -1;
      }

      getLoadedFraction() {
        return 1;
      }

      play() {}

      pause() {}

      seekTo(time, paused = false) {}

      getCurrentTime() {}

      getDuration() {}

    };

    SyncTubeClient_Player_StuiBanned.prototype.ctype = "StuiBanned";

    return SyncTubeClient_Player_StuiBanned;

  }).call(this);

  window.SyncTubeClient_Player_StuiCreateForm = SyncTubeClient_Player_StuiCreateForm = (function() {
    class SyncTubeClient_Player_StuiCreateForm {
      constructor(client1) {
        this.client = client1;
        this.vp = $("<div>", {
          id: "view_stui_create_form",
          width: "100%",
          height: "100%"
        }).fadeIn(3000).appendTo(this.client.view);
        this.buildForm();
        this.clientUpdate();
        this.vp.on("focus", "input,button", (ev) => {
          if ($(ev.target).attr("name") === "name") {
            return;
          }
          this.vp.find("input,button").attr("data-last-focused", false);
          return $(ev.target).attr("data-last-focused", true);
        });
        this.vp.on("submit", "form", (ev) => {
          var cmd, control, data, fd, fdata, j, len;
          fdata = $(ev.target).serializeArray();
          control = this.vp.find("input[data-last-focused=true],button[data-last-focused=true]").attr("name") === "channel_password";
          if (this.vp.find("input[name=channel_password]").val()) {
            control = true;
          }
          data = {};
          for (j = 0, len = fdata.length; j < len; j++) {
            fd = fdata[j];
            data[fd.name] = fd.value;
          }
          this.vp.find(".invalid-feedback").remove();
          this.vp.find("input.is-invalid").removeClass("is-invalid");
          if (!this.client.name && !data.name) {
            $("<div class=\"invalid-feedback\">choose a name</div>").insertAfter(this.vp.find("input[name=name]").addClass("is-invalid"));
            return false;
          }
          // space in name
          if ((data.name + "").match(/\s+/)) {
            $("<div class=\"invalid-feedback\">may not contain white spaces</div>").appendTo(this.vp.find("input[name=name]").addClass("is-invalid").parent());
            return false;
          }
          // space in channel
          if ((data.channel + "").match(/\s+/)) {
            $("<div class=\"invalid-feedback\">may not contain white spaces</div>").appendTo(this.vp.find("input[name=channel]").addClass("is-invalid").parent());
            return false;
          }
          // space in pw
          if ((data.channel_password + "").match(/\s+/)) {
            $("<div class=\"invalid-feedback\">may not contain white spaces</div>").appendTo(this.vp.find("input[name=channel_password]").addClass("is-invalid").parent());
            return false;
          }
          cmd = `/${(control ? "control" : "join")} ${data.channel}`;
          if (control && data.channel_password) {
            cmd += ` ${data.channel_password}`;
          }
          if (!this.client.name) {
            this.client.connection.send(data.name);
          } else if (data.name && this.client.name !== data.name) {
            this.client.connection.send(`/rename ${data.name}`);
          }
          if (data.channel) {
            this.client.connection.send(cmd);
          }
          return false;
        });
      }

      destroy() {
        return this.vp.remove();
      }

      buildForm() {
        return this.vp.append("<div class=\"flexcentered\" style=\"color: rgba(255, 255, 255, 0.88);\">\n  <div style=\"max-width: 800px\">\n    <div style=\"margin-bottom: 50px\"><h1>Welcome to Sync<span style=\"color: #ff0201\">Tube</span></h1></div>\n    <form class=\"form-horizontal\" id=\"optform\" style=\"max-width: 400px; margin: 0px auto\">\n      <div class=\"form-group\"><input type=\"text\" class=\"form-control outline-danger\" placeholder=\"tell me your name (no spaces)\" name=\"name\" autofocus=\"autofocus\"></div>\n      <div class=\"form-group text-center\">and join a</div>\n      <div class=\"form-group input-group\">\n        <input type=\"text\" class=\"form-control\" placeholder=\"channel (no spaces)\" name=\"channel\">\n        <div class=\"input-group-append\">\n          <button class=\"btn btn-outline-inverse btn-success\" name=\"channel\" type=\"submit\" value=\"join\">join</button>\n        </div>\n      </div>\n      <div class=\"form-group text-center\">or be a host</div>\n      <div class=\"form-group input-group text-center\">\n        <input type=\"password\" class=\"form-control\" placeholder=\"channel password (optional)\" name=\"channel_password\">\n        <div class=\"input-group-append\">\n          <button class=\"btn btn-outline-inverse btn-primary\" type=\"submit\" name=\"channel_password\" value=\"control\">create/control</button>\n        </div>\n      </div>\n    </form>\n  </div>\n</div>");
      }

      clientUpdate() {
        var hparams, x;
        hparams = this.client.getHashParams();
        if (this.client.name) {
          this.vp.find("input[name=name]").val(this.client.name);
        }
        if (x = hparams.control || hparams.channel || hparams.join) {
          this.vp.find("input[name=channel]").val(x);
        }
        if (x = hparams.password) {
          return this.vp.find("input[name=channel_password]").val(x);
        }
      }

      // null api functions
      updateDesired(data) {}

      getUrl() {
        return "STUI:CreateForm";
      }

      getState() {
        return -1;
      }

      getLoadedFraction() {
        return 1;
      }

      play() {}

      pause() {}

      seekTo(time, paused = false) {}

      getCurrentTime() {}

      getDuration() {}

    };

    SyncTubeClient_Player_StuiCreateForm.prototype.ctype = "StuiCreateForm";

    return SyncTubeClient_Player_StuiCreateForm;

  }).call(this);

  window.SyncTubeClient_Player_StuiKicked = SyncTubeClient_Player_StuiKicked = (function() {
    class SyncTubeClient_Player_StuiKicked {
      constructor(client1) {
        this.client = client1;
        this.vp = $("<div>", {
          id: "view_stui_kicked",
          width: "100%",
          height: "100%"
        }).fadeIn(3000).appendTo(this.client.view);
        this.buildView();
        this.vp.on("click", "a", () => {
          this.client.CMD_desired({
            ctype: "StuiCreateForm"
          });
          return false;
        });
      }

      destroy() {
        return this.vp.remove();
      }

      buildView() {
        return this.vp.append("<div class=\"flexcentered\" style=\"color: rgba(255, 255, 255, 0.88);\">\n  <div style=\"max-width: 800px\">\n    <div class=\"alert alert-danger\">\n      <h1 class=\"alert-heading\"><i class=\"fa fa-warning\"></i> You got kicked!</h1>\n      <big><strong data-reason>you got kicked by a channel or server admin</strong></big>\n    </div>\n    <a href=\"#\" class=\"btn btn-primary\" style=\"display: none\">got it</a>\n  </div>\n</div>");
      }

      updateDesired(data) {
        if (data.info.reason) {
          this.vp.find("[data-reason]").html(data.info.reason);
        }
        if (data.info.type !== "session_kicked") {
          return this.vp.find("a").show();
        }
      }

      // null api functions
      getUrl() {
        return "STUI:CreateForm";
      }

      getState() {
        return -1;
      }

      getLoadedFraction() {
        return 1;
      }

      play() {}

      pause() {}

      seekTo(time, paused = false) {}

      getCurrentTime() {}

      getDuration() {}

    };

    SyncTubeClient_Player_StuiKicked.prototype.ctype = "StuiKicked";

    return SyncTubeClient_Player_StuiKicked;

  }).call(this);

  window.SyncTubeClient_Player_Youtube = SyncTubeClient_Player_Youtube = (function() {
    class SyncTubeClient_Player_Youtube {
      constructor(client1) {
        this.client = client1;
      }

      destroy() {
        var ref1;
        this.rememberVolume();
        if ((ref1 = this.api) != null) {
          ref1.destroy();
        }
        this.api = null;
        return this.pauseEnsured("player destroy");
      }

      updateDesired(data) {
        var current_ytid, lastPacketDiff, ref1, ref2;
        this.desired = data;
        this.rememberVolume();
        if (!this.api) {
          this.loadVideo(data.url, data.state !== "play", data.seek);
          return;
        }
        current_ytid = (ref1 = this.getUrl()) != null ? (ref2 = ref1.match(/([A-Za-z0-9_\-]{11})/)) != null ? ref2[0] : void 0 : void 0;
        if ((current_ytid !== data.url || data.forceLoad) && !this.disableSourceSync) {
          if (current_ytid == null) {
            return;
          }
          this.client.debug("switching video from", current_ytid, "to", data.url);
          this.loadVideo(data.url);
          if (data.state === "pause") {
            this.ensurePause(data);
          }
          return;
        }
        if (this.getState() === 1 && data.state === "pause") {
          this.client.debug("pausing playback, state:", this.getState());
          this.pause();
          this.seekTo(data.seek, true);
          this.ensurePause(data);
          return;
        }
        if (this.getState() !== 1 && data.state === "play") {
          lastPacketDiff = this.client.lastPacketSent ? (new Date()) - this.client.lastPacketSent : null;
          if ((lastPacketDiff != null) && lastPacketDiff < 75 && this.getState() === 0) {
            this.client.debug("ignore starting playback, stopped and we just sent packet", lastPacketDiff);
          } else {
            this.client.debug("starting playback, state:", this.getState());
            this.pauseEnsured("starting playback");
            this.play();
          }
          return;
        }
        if (Math.abs(this.client.drift * 1000) > this.client.opts.synced.maxDrift || this.force_resync || data.force) {
          this.force_resync = false;
          this.client.debug("seek to correct drift", this.client.drift, data.seek, this.getState());
          if (!(this.getCurrentTime() === 0 && data.seek === 0)) {
            this.seekTo(data.seek, true);
          }
          // ensure paused player at correct position when it was cued
          // seekTo on a cued video will start playback delayed
          return this.ensurePause(data);
        }
      }

      seekTo(time, paused = false) {
        var ref1, ref2, ref3;
        if ((ref1 = this.api) != null) {
          if (typeof ref1.seekTo === "function") {
            ref1.seekTo(time, true);
          }
        }
        if (paused) {
          return (ref2 = this.player) != null ? ref2.pause() : void 0;
        } else {
          return (ref3 = this.player) != null ? ref3.play() : void 0;
        }
      }

      getState() {
        var ref1;
        if (((ref1 = this.api) != null ? ref1.getPlayerState : void 0) != null) {
          return this.api.getPlayerState();
        } else {
          return -1;
        }
      }

      play() {
        var ref1;
        return (ref1 = this.api) != null ? typeof ref1.playVideo === "function" ? ref1.playVideo() : void 0 : void 0;
      }

      pause() {
        var ref1;
        return (ref1 = this.api) != null ? typeof ref1.pauseVideo === "function" ? ref1.pauseVideo() : void 0 : void 0;
      }

      getCurrentTime() {
        var ref1;
        if (((ref1 = this.api) != null ? ref1.getCurrentTime : void 0) != null) {
          return this.api.getCurrentTime();
        } else {
          return 0;
        }
      }

      getDuration() {
        var ref1;
        if (((ref1 = this.api) != null ? ref1.getDuration : void 0) != null) {
          return this.api.getDuration();
        } else {
          return 0;
        }
      }

      getLoadedFraction() {
        var ref1;
        if (((ref1 = this.api) != null ? ref1.getVideoLoadedFraction : void 0) != null) {
          return this.api.getVideoLoadedFraction();
        } else {
          return 0;
        }
      }

      getUrl() {
        var ref1, ref2, ref3;
        return (ref1 = this.api) != null ? typeof ref1.getVideoUrl === "function" ? (ref2 = ref1.getVideoUrl()) != null ? (ref3 = ref2.match(/([A-Za-z0-9_\-]{11})/)) != null ? ref3[0] : void 0 : void 0 : void 0 : void 0;
      }

      // ----------------------
      loadYTAPI(callback) {
        var firstScriptTag, tag;
        if (document.YouTubeIframeAPIHasLoaded) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        window.onYouTubeIframeAPIReady = () => {
          document.YouTubeIframeAPIHasLoaded = true;
          return typeof callback === "function" ? callback() : void 0;
        };
        tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        firstScriptTag = document.getElementsByTagName('script')[0];
        return firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
      }

      loadVideo(ytid, cue = false, seek = 0) {
        var m;
        if (m = ytid.match(/([A-Za-z0-9_\-]{11})/)) {
          ytid = m[1];
        } else {
          throw "unknown ID";
        }
        return this.loadYTAPI(() => {
          var base, base1;
          if (this.api) {
            if (cue) {
              if (typeof (base = this.api).cueVideoById === "function") {
                base.cueVideoById(ytid, seek);
              }
            } else {
              if (typeof (base1 = this.api).loadVideoById === "function") {
                base1.loadVideoById(ytid, seek);
              }
            }
            return this.api;
          } else {
            return this.api = new YT.Player('view', {
              videoId: ytid,
              height: '100%',
              width: '100%',
              //playerVars: controls: 0
              events: {
                onReady: (ev) => {
                  var ref1, vol;
                  // restore saved volume
                  vol = (ref1 = this.client.history) != null ? ref1.LSload("player_volume") : void 0;
                  if (vol != null) {
                    this.client.debug(`Restored player volume ${vol}`);
                    this.api.setVolume(vol);
                  }
                  if (cue) {
                    this.api.cueVideoById(ytid, seek);
                  } else {
                    this.seekTo(seek);
                    this.play();
                  }
                  this.client.broadcastState(ev.data);
                  this.lastPlayerState = this.getState() != null ? this.getState() : 2;
                  return this.client.startBroadcast();
                },
                onStateChange: (ev) => {
                  var newState;
                  newState = this.getState();
                  if (!this.client.dontBroadcast && (this.lastPlayerState != null) && ([-1, 2].indexOf(this.lastPlayerState) > -1 && [1, 3].indexOf(newState) > -1)) {
                    console.log("send resume", this.lastPlayerState, newState);
                    this.client.sendControl("/resume");
                  } else if (!this.client.dontBroadcast && (this.lastPlayerState != null) && ([1, 3].indexOf(this.lastPlayerState) > -1 && [2].indexOf(newState) > -1)) {
                    console.log("send pause");
                    this.client.sendControl("/pause");
                  }
                  console.log("state", "was", this.lastPlayerState, "is", newState);
                  this.lastPlayerState = newState;
                  return this.client.broadcastState(ev.data);
                }
              }
            });
          }
        });
      }

      ensurePause(data) {
        var fails;
        this.client.dontBroadcast = true;
        fails = 0;
        clearInterval(this.ensurePauseInterval);
        return this.ensurePauseInterval = setInterval((() => {
          if (this.getState() == null) {
            if ((fails += 1) > 100) {
              this.pauseEnsured(`giving up after ${fails} attempts`);
            }
            return;
          }
          if (data.state !== "pause") {
            return this.pauseEnsured("not paused");
          }
          if (this.getCurrentTime() === 0 && data.seek === 0 && [1, 3].indexOf(this.getState()) === -1) {
            //return @pauseEnsured("state not 5 or -1 (#{@getState()})") unless [5, -1].indexOf(@getState()) > -1
            return this.pauseEnsured("timecode 0");
          }
          if ([-1, 2].indexOf(this.getState()) > -1 && Math.abs(this.getCurrentTime() - data.seek) <= 0.5) {
            this.pauseEnsured(`drift done after ${fails} attempts`);
            return this.client.broadcastState();
          } else {
            this.seekTo(data.seek, true);
            this.play() && this.pause();
            if ((fails += 1) > 100) {
              return this.pauseEnsured(`giving up after ${fails} attempts`);
            }
          }
        }), 100);
      }

      pauseEnsured(reason) {
        this.client.debug(`YT pause ensured (${reason})`);
        clearInterval(this.ensurePauseInterval);
        this.client.dontBroadcast = false;
        return this.client.sendControl("/ready");
      }

      rememberVolume() {
        var ref1, stored, vol;
        if (this.client.history == null) {
          return;
        }
        vol = (ref1 = this.api) != null ? typeof ref1.getVolume === "function" ? ref1.getVolume() : void 0 : void 0;
        stored = this.client.history.LSload("player_volume");
        if ((vol != null) && ((stored == null) || stored !== vol)) {
          this.client.debug(`Remembered player volume ${vol}`);
          return this.client.history.LSsave("player_volume", vol);
        }
      }

    };

    SyncTubeClient_Player_Youtube.prototype.ctype = "Youtube";

    return SyncTubeClient_Player_Youtube;

  }).call(this);

  window.SyncTubeClient_UI = {
    init: function() {
      var base, base1, j, l, len, len1, ref1, ref2, results, x;
      this.refocus = false;
      if ((base = this.opts).maxWidth == null) {
        base.maxWidth = 12;
      }
      ref1 = this.VIEW_COMPONENTS;
      for (j = 0, len = ref1.length; j < len; j++) {
        x = ref1[j];
        if ((base1 = this.opts)[x] == null) {
          base1[x] = $(`#${x}`);
        }
      }
      ref2 = this.VIEW_COMPONENTS;
      results = [];
      for (l = 0, len1 = ref2.length; l < len1; l++) {
        x = ref2[l];
        results.push(this[x] = $(this.opts[x]));
      }
      return results;
    },
    start: function() {
      this.adjustMaxWidth();
      this.captureInput();
      return this.handleWindowResize();
    },
    adjustMaxWidth: function(i) {
      var hparams, maxWidth;
      hparams = this.getHashParams();
      maxWidth = i || hparams.maxWidth || hparams.width || hparams.mw || this.opts.maxWidth;
      return $("#page > .col").attr("class", `col col-${maxWidth}`);
    },
    handleWindowResize: function() {
      $(window).resize((ev) => {
        var height_both, height_first, height_second, height_third, width_second;
        if (!$("#page").is(":visible")) {
          return;
        }
        height_first = $("#first_row").height();
        height_second = $("#second_row").height();
        height_third = $("#third_row").height();
        width_second = $("#second_row").width();
        //height_both = height_first + height_second + 30
        height_both = height_first + height_second + height_third + 30;
        if (height_both > window.innerHeight && width_second > 500) {
          $("#page").css({
            maxWidth: $("#page").width() - 2
          });
          window.scrollTo(0, 0);
          this.delay(1, () => {
            return $(window).resize();
          });
        } else if ((window.innerHeight - height_both) > 1 && $(document).innerWidth() > $("#page").width()) {
          $("#page").css({
            maxWidth: $("#page").width() + 2
          });
          window.scrollTo(0, 0);
          this.delay(1, () => {
            return $(window).resize();
          });
        }
        if ($("#first_row").width() > 800) {

        } else {

        }
        //console.log "DEATTACH playlist"
        //$("#playlist").detach().appendTo("#playlist_ctn")
        //console.log "ATTACH playlist"
        //$("#playlist").detach()#.appendTo("#view_ctn")
        return this.playlist.scrollTop(this.playlist.find("div.active").prop("offsetTop") - 15);
      });
      return $(window).resize();
    },
    //setTimeout((-> $(window).resize()), 100)
    captureInput: function() {
      this.input.keydown((event) => {
        var i, m, msg, ref1;
        if (event.keyCode !== 13) {
          return true;
        }
        if (!(msg = this.input.val())) {
          return;
        }
        if ((ref1 = this.history) != null) {
          ref1.append(msg);
        }
        if (msg.charAt(0) === "/") {
          this.addSendCommand(msg);
        }
        if (m = msg.match(/^\/(?:mw|maxwidth|width)(?:\s([0-9]+))?$/i)) {
          i = parseInt(m[1]);
          if (m[1] && i >= 1 && i <= 12) {
            this.adjustMaxWidth(this.opts.maxWidth = i);
            this.input.val("");
          } else {
            this.content.append("<p>Usage: /maxwidth [1-12]</p>");
          }
          return;
        }
        this.connection.send(msg);
        return this.disableInput();
      });
      this.input.parent().click((event) => {
        if (this.input.is(":disabled")) {
          return this.input_nofocus.focus();
        }
      });
      this.input_nofocus.blur((event) => {
        return this.refocus = false;
      });
      this.input_nofocus.focus((event) => {
        return this.refocus = true;
      });
      $(document).on("click", "[data-command]", (event) => {
        var cmd, el;
        el = $(event.currentTarget);
        cmd = el.data("command");
        if (event.altKey && el.data("altCommand")) {
          cmd = el.data("altCommand");
        }
        this.connection.send("/" + cmd);
        return false;
      });
      return $(document).on("click", "[data-suggest-command]", (event) => {
        var cmd, el;
        el = $(event.currentTarget);
        cmd = el.data("suggestCommand");
        if (event.altKey && el.data("altCommand")) {
          cmd = el.data("altCommand");
        }
        el.closest(".dropdown-menu").prev().dropdown("toggle");
        this.input.val("/" + cmd).focus();
        return false;
      });
    },
    enableInput: function(focus = true, clear = true) {
      if (clear && this.input.is(":disabled")) {
        this.input.val("");
      }
      this.input.removeAttr("disabled");
      if (this.refocus && focus) {
        this.input.focus();
      }
      return this.input;
    },
    disableInput: function() {
      this.input.attr("disabled", "disabled");
      this.input_nofocus.focus();
      return this.input;
    },
    addError: function(error) {
      var dt;
      dt = new Date();
      this.content.append(`<p>\n  <strong style="color: #ee5f5b">error</strong>\n  @ ${`0${dt.getHours()}`.slice(-2)}:${`0${dt.getMinutes()}`.slice(-2)}\n  <span style="color: #ee5f5b">${error}</span>\n</p>`);
      return this.content.scrollTop(this.content.prop("scrollHeight"));
    },
    addMessage: function(data) {
      var dt, tagname;
      dt = new Date(data.time);
      tagname = data.author === "system" ? "strong" : "span";
      this.content.append(`<p>\n  <${tagname} style="color:${data.author_color}">${data.author}</${tagname}>\n  @ ${`0${dt.getHours()}`.slice(-2)}:${`0${dt.getMinutes()}`.slice(-2)}\n  <span style="color: ${data.text_color}">${data.text}</span>\n</p>`);
      return this.content.scrollTop(this.content.prop("scrollHeight"));
    },
    buildPlaylistElement: function(data) {
      return $(`<div data-pl-id="${data.id}" data-pl-index="${data.index}">\n  <span class="first">\n    <img src="" data-attr="thumbnail" data-command="pl play ${data.index}" title="play">\n  </span>\n  <span class="second">\n    <a data-attr="name"></a>\n    <a data-attr="author"></a>\n    <span class="active_indicator text-danger"><i class="fa fa-circle"></i> now playing</span>\n    <span class="btn-group">\n      <span class="btn btn-success btn-xs" data-command="pl play ${data.index}"><i class="fa fa-play"></i></span>\n      <span class="btn btn-danger btn-xs" data-command="pl remove ${data.index}"><i class="fa fa-times"></i></span>\n    </span>\n  </span>\n</div>`);
    },
    buildSubscriberElement: function() {
      return $("<div data-client-index=\"\">\n  <div class=\"first\">\n    <span data-attr=\"admin-ctn\"><i></i></span>\n    <span data-attr=\"name\"></span>\n  </div>\n  <div class=\"second\">\n    <span data-attr=\"icon-ctn\"><i><span data-attr=\"progress\"></span> <span data-attr=\"timestamp\"></span></i></span>\n    <span data-attr=\"drift-ctn\" style=\"float:right\"><i><span data-attr=\"drift\"></span></i></span>\n    <div data-attr=\"progress-bar\"><div data-attr=\"progress-bar-buffered\"></div><div data-attr=\"progress-bar-position\"></div></div>\n  </div>\n</div>");
    },
    addSendCommand: function(msg) {
      var dt;
      dt = new Date();
      this.content.append(`<p style="color: #7a8288">\n  <span><i class="fa fa-terminal"></i></span>\n  @ ${`0${dt.getHours()}`.slice(-2)}:${`0${dt.getMinutes()}`.slice(-2)}\n  <span>${msg}</span>\n</p>`);
      return this.content.scrollTop(this.content.prop("scrollHeight"));
    }
  };

  window.SyncTubeClient_Util = {
    getHashParams: function() {
      var j, key, kv, kvp, len, parts, result;
      result = {};
      if (window.location.hash) {
        parts = window.location.hash.substr(1).split("&");
        for (j = 0, len = parts.length; j < len; j++) {
          kv = parts[j];
          kvp = kv.split("=");
          key = kvp.shift();
          result[key] = kvp.join("=");
        }
      }
      return result;
    },
    delay: function(ms, func) {
      return setTimeout(func, ms);
    }
  };

  // ./client/*.coffee will be inserted here by "npm run build" or "npm run dev"
  $(function() {
    var client;
    client = new SyncTubeClient({
      debug: true
    });
    return client.welcome(() => {
      return client.start();
    });
  });

}).call(this);
