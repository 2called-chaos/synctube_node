// Generated by CoffeeScript 2.3.2
(function() {
  var SyncTubeClient;

  window.SyncTubeClient = SyncTubeClient = (function() {
    class SyncTubeClient {
      debug(...msg) {
        if (!this.opts.debug) {
          return;
        }
        msg.unshift(`[ST ${(new Date).toISOString()}]`);
        return console.debug.apply(this, msg);
      }

      warn(...msg) {
        msg.unshift(`[ST ${(new Date).toISOString()}]`);
        return console.warn.apply(this, msg);
      }

      error(...msg) {
        msg.unshift(`[ST ${(new Date).toISOString()}]`);
        return console.error.apply(this, msg);
      }

      constructor(opts = {}) {
        var base, base1, base2, base3, base4, base5, base6, base7, base8;
        this.opts = opts;
        // options
        if ((base = this.opts).debug == null) {
          base.debug = false;
        }
        if ((base1 = this.opts).maxWidth == null) {
          base1.maxWidth = 12;
        }
        if ((base2 = this.opts).content == null) {
          base2.content = $("#content");
        }
        if ((base3 = this.opts).view == null) {
          base3.view = $("#view");
        }
        if ((base4 = this.opts).input == null) {
          base4.input = $("#input");
        }
        if ((base5 = this.opts).status == null) {
          base5.status = $("#status");
        }
        if ((base6 = this.opts).queue == null) {
          base6.queue = $("#queue");
        }
        if ((base7 = this.opts).playlist == null) {
          base7.playlist = $("#playlist");
        }
        if ((base8 = this.opts).clients == null) {
          base8.clients = $("#clients");
        }
        // DOM
        this.content = $(this.opts.content);
        this.view = $(this.opts.view);
        this.input = $(this.opts.input);
        this.status = $(this.opts.status);
        this.queue = $(this.opts.queue);
        this.playlist = $(this.opts.playlist);
        this.clients = $(this.opts.clients);
        // Client data
        this.name = null;
      }

      getHashParams() {
        var j, key, kv, kvp, len, parts, result;
        result = {};
        if (window.location.hash) {
          parts = window.location.hash.substr(1).split("&");
          for (j = 0, len = parts.length; j < len; j++) {
            kv = parts[j];
            kvp = kv.split("=");
            key = kvp.shift();
            result[key] = kvp.join("=");
          }
        }
        return result;
      }

      start() {
        this.adjustMaxWidth();
        this.openWSconnection();
        this.detectBrokenConnection();
        this.captureInput();
        return this.listen();
      }

      adjustMaxWidth(i) {
        var hparams, maxWidth;
        hparams = this.getHashParams();
        maxWidth = i || hparams.maxWidth || hparams.width || hparams.mw || this.opts.maxWidth;
        return $("#page > .col").attr("class", `col col-${maxWidth}`);
      }

      openWSconnection() {
        var address;
        // mozilla fallback
        window.WebSocket = window.WebSocket || window.MozWebSocket;
        // if browser doesn't support WebSocket, just show some notification and exit
        if (!window.WebSocket) {
          this.content.html($("<p>", {
            text: "Sorry, but your browser doesn't support WebSocket."
          }));
          this.status.hide();
          this.input.hide();
          return;
        }
        // open connection
        address = `ws://${this.WS_IP}:${this.WS_PORT}`;
        this.debug(`Opening connection to ${address}`);
        this.connection = new WebSocket(address);
        this.connection.onopen = () => {
          return this.debug("WS connection opened");
        };
        return this.connection.onerror = (error) => {
          this.error("WS connection encountered an error", error);
          return this.content.html($("<p>", {
            text: "Sorry, but there's some problem with your connection or the server is down."
          }));
        };
      }

      detectBrokenConnection() {
        return setInterval((() => {
          if (this.connection.readyState !== 1) {
            this.status.text("Error");
            this.disableInput().val("Unable to communicate with the WebSocket server. Please reload!");
            return window.location.reload();
          }
        }), 3000);
      }

      captureInput() {
        return this.input.keydown((event) => {
          var i, m, msg;
          if (event.keyCode !== 13) {
            return true;
          }
          if (!(msg = this.input.val())) {
            return;
          }
          if (m = msg.match(/\/(?:mw|maxwidth|width)(?:\s([0-9]+))?/i)) {
            i = parseInt(m[1]);
            if (m[1] && i >= 1 && i <= 12) {
              this.adjustMaxWidth(this.opts.maxWidth = i);
              this.input.val("");
            } else {
              this.content.append("<p>Usage: /maxwidth [1-12]</p>");
            }
            return;
          }
          this.connection.send(msg);
          return this.disableInput().val("");
        });
      }

      listen() {
        return this.connection.onmessage = (message) => {
          var error, json;
          try {
            json = JSON.parse(message.data);
          } catch (error1) {
            error = error1;
            this.error("Invalid JSON", message.data, error);
            return;
          }
          switch (json.type) {
            case "code":
              this.debug("received CODE", json.data);
              if (this[`CMD_${json.data.type}`] != null) {
                return this[`CMD_${json.data.type}`](json.data);
              } else {
                return this.warn(`no client implementation for CMD_${json.data.type}`);
              }
              break;
            case "message":
              this.debug("received MESSAGE", json.data);
              return this.addMessage(json.data);
            default:
              return this.warn("Hmm..., I've never seen JSON like this:", json);
          }
        };
      }

      enableInput(focus = true) {
        this.input.removeAttr("disabled");
        if (focus) {
          this.input.focus();
        }
        return this.input;
      }

      disableInput() {
        this.input.attr("disabled", "disabled");
        return this.input;
      }

      addMessage(data) {
        var dt, tagname;
        dt = new Date(data.time);
        tagname = data.author === "system" ? "strong" : "span";
        this.content.append(`<p>\n  <${tagname} style="color:${data.author_color}">${data.author}</${tagname}>\n  @ ${`0${dt.getHours()}`.slice(-2)}:${`0${dt.getMinutes()}`.slice(-2)}\n  <span style="color: ${data.text_color}">${data.text}</span>\n</p>`);
        return this.content.scrollTop(this.content.prop("scrollHeight"));
      }

      // =============
      // = YT Player =
      // =============
      loadYTAPI(callback) {
        var firstScriptTag, tag;
        if (document.YouTubeIframeAPIHasLoaded) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        window.onYouTubeIframeAPIReady = () => {
          document.YouTubeIframeAPIHasLoaded = true;
          return typeof callback === "function" ? callback() : void 0;
        };
        tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        firstScriptTag = document.getElementsByTagName('script')[0];
        return firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
      }

      loadVideo(ytid, cue = false) {
        return this.loadYTAPI(() => {
          if (this.player) {
            if (cue) {
              this.player.cueVideoById(ytid);
            } else {
              this.player.loadVideoById(ytid);
            }
            return this.player;
          } else {
            return window.player = this.player = new YT.Player('view', {
              videoId: ytid,
              height: '100%',
              width: '100%',
              events: {
                onReady: (ev) => {
                  if (!cue) {
                    this.player.playVideo();
                  }
                  this.broadcastState(ev);
                  return this.broadcastStateInterval = setInterval((() => {
                    var ref, ref1;
                    return this.broadcastState({
                      data: ((ref = this.player) != null ? ref.getPlayerState() : void 0) != null ? (ref1 = this.player) != null ? ref1.getPlayerState() : void 0 : 2
                    });
                  }), this.REFRESH_INTERVAL);
                },
                onStateChange: (ev) => {
                  return this.broadcastState(ev);
                }
              }
            });
          }
        });
      }

      secondsToTime(cur, max) {
        var mf, mh, mm, ms, r, sf, sh, sm, ss;
        mh = null;
        mm = null;
        ms = null;
        mf = null;
        if (max >= (60 * 60)) {
          mh = parseInt(max / (60 * 60));
          max %= 60 * 60;
        }
        if (max >= 60) {
          mm = parseInt(max / 60);
          max %= 60;
        }
        ms = ("0" + parseInt(max)).slice(-2);
        mf = max.toFixed(1).toString().split(".");
        mf = mf[mf.length - 1];
        sh = null;
        sm = null;
        ss = null;
        sf = null;
        if (cur >= (60 * 60)) {
          sh = parseInt(cur / (60 * 60));
          cur %= 60 * 60;
        }
        if (cur >= 60) {
          sm = parseInt(cur / 60);
          cur %= 60;
        }
        ss = ("0" + parseInt(cur)).slice(-2);
        sf = cur.toFixed(1).toString().split(".");
        sf = sf[sf.length - 1];
        r = "";
        if (mh != null) {
          r += `0${sh}:`.slice(mh >= 10 ? -3 : -2);
        }
        if ((mh != null) || (mm != null)) {
          r += `0${sm || 0}:`.slice(mm >= 10 || (mh != null) ? -3 : -2);
        }
        r += `0${ss}`.slice(-2);
        r += `.${sf}`;
        r += "/";
        if (mh != null) {
          r += `0${mh}:`.slice(mh >= 10 ? -3 : -2);
        }
        if ((mh != null) || (mm != null)) {
          r += `0${mm}:`.slice(mm >= 10 || (mh != null) ? -3 : -2);
        }
        r += `0${ms}`.slice(-2);
        if (mf !== "0") {
          r += `.${mf}`;
        }
        return r;
      }

      broadcastState(ev) {
        var packet, ref, ref1, state;
        state = (function() {
          switch (ev != null ? ev.data : void 0) {
            case -1:
              return "unstarted";
            case 0:
              return "ended";
            case 1:
              return "playing";
            case 2:
              return "paused";
            case 3:
              return "buffering";
            case 5:
              return "cued";
            default:
              return "ready";
          }
        })();
        packet = {
          state: state,
          istate: ev != null ? ev.data : void 0,
          seek: (ref = this.player) != null ? ref.getCurrentTime() : void 0,
          playtime: (ref1 = this.player) != null ? ref1.getDuration() : void 0,
          loaded_fraction: player.getVideoLoadedFraction(),
          url: player.getVideoUrl()
        };
        if ((packet.seek != null) && (packet.playtime != null)) {
          packet.timestamp = this.secondsToTime(packet.seek, packet.playtime);
        }
        this.connection.send("!packet:" + JSON.stringify(packet));
        return console.log(packet);
      }

      // ========
      // = CMDS =
      // ========
      CMD_load_video(data) {
        return this.loadVideo(data.ytid, data.cue);
      }

      CMD_ack() {
        return this.enableInput();
      }

      CMD_unsubscribe() {
        return clearInterval(this.broadcastStateInterval);
      }

      CMD_video_action(data) {
        console.log("<<<<<<<<<<<<<<<<<<<", data);
        switch (data.action) {
          case "resume":
            return this.player.playVideo();
          case "pause":
            return this.player.pauseVideo();
          case "seek":
            this.player.seekTo(data.to, true);
            if (data.paused) {
              return this.player.pauseVideo();
            } else {
              return this.player.playVideo();
            }
        }
      }

      CMD_navigate(data) {
        if (data.reload) {
          return window.location.reload();
        } else if (data.location) {
          return window.location.href = data.location;
        }
      }

      CMD_require_username(data) {
        var hparams, p;
        this.enableInput();
        this.status.text("Choose name:");
        // check hash params
        if (data.autofill === false) {
          return;
        }
        hparams = this.getHashParams();
        if (p = hparams.user || hparams.username || hparams.name) {
          return this.connection.send(p);
        }
      }

      CMD_username(data) {
        var ch, cmd, hparams;
        this.name = data.username;
        this.status.text(`${this.name}:`);
        // check hash params
        hparams = this.getHashParams();
        if (ch = hparams.channel || hparams.join) {
          this.connection.send(`/join ${ch}`);
        }
        if (hparams.control) {
          cmd = `/control ${hparams.control}`;
          if (hparams.password != null) {
            cmd += ` ${hparams.password}`;
          }
          return this.connection.send(cmd);
        }
      }

      CMD_update_single_subscriber(resp) {
        var data, el, k, ref, v;
        data = (resp != null ? resp.data : void 0) || {};
        if (data.index == null) {
          return;
        }
        el = this.clients.find(`[data-client-index=${data.index}]`);
        if (!el.length) {
          el = $(`<div data-client-index="${data.index}">\n  <div class="first">\n    <span data-attr="admin-ctn"><i title="ADMIN"></i></span>\n    <span data-attr="name"></span>\n  </div>\n  <div class="second">\n    <span data-attr="icon-ctn"><i><span data-attr="progress"></span> <span data-attr="timestamp"></span></i></span>\n    <span data-attr="drift-ctn" style="float:right"><i><span data-attr="drift"></span></i></span>\n    <div data-attr="progress-bar"><div data-attr="progress-bar-buffered"></div><div data-attr="progress-bar-position"></div></div>\n  </div>\n</div>`);
          this.clients.append(el);
        }
        for (k in data) {
          v = data[k];
          el.find(`[data-attr=${k}]`).html(v);
        }
        ref = data.state;
        for (k in ref) {
          v = ref[k];
          el.find(`[data-attr=${k}]`).html(v);
        }
        el.find("[data-attr=progress-bar-buffered]").css({
          width: `${(data.state.loaded_fraction || 0) * 100}%`
        });
        el.find("[data-attr=progress-bar-position]").css({
          left: `${(data.state.seek <= 0 ? 0 : data.state.seek / data.state.playtime * 100)}%`
        });
        if (data.icon) {
          el.find("[data-attr=icon-ctn] i").attr("class", `fa fa-${data.icon} ${data.icon_class}`);
        }
        if (data.control) {
          el.find("[data-attr=admin-ctn] i").attr("class", "fa fa-shield text-info");
        }
        el.find("[data-attr=drift-ctn] i").attr("class", `fa fa-${(data.drift ? data.drift > 0 ? "backward" : "forward" : "circle-o-notch")} text-warning`);
        return el.find("[data-attr=drift]").html(el.find("[data-attr=drift]").html().replace("-", ""));
      }

      CMD_subscriber_list(data) {
        var j, len, ref, results, sub;
        this.clients.html("");
        ref = data.subscribers;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          sub = ref[j];
          results.push(this.CMD_update_single_subscriber({
            data: sub
          }));
        }
        return results;
      }

    };

    SyncTubeClient.prototype.WS_IP = "127.0.0.1";

    SyncTubeClient.prototype.WS_PORT = 1337;

    SyncTubeClient.prototype.REFRESH_INTERVAL = 2000;

    return SyncTubeClient;

  }).call(this);

  $(function() {
    var client;
    client = new SyncTubeClient({
      debug: true
    });
    return client.start();
  });

}).call(this);
