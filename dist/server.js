// Generated by CoffeeScript 2.3.2
(function() {
  // requires
  var COLORS, SyncTubeServer, fs, http, server, webSocketServer;

  http = require('http');

  fs = require('fs');

  webSocketServer = require('websocket').server;

  COLORS = {
    green: "#62c462",
    success: "#62c462",
    red: "#ee5f5b",
    danger: "#ee5f5b",
    yellow: "#f89406",
    warning: "#f89406",
    aqua: "#5bc0de",
    info: "#5bc0de",
    muted: "#7a8288"
  };

  SyncTubeServer = (function() {
    var Channel, Client;

    class SyncTubeServer {
      debug(...msg) {
        if (!this.opts.debug) {
          return;
        }
        msg.unshift(new Date);
        msg.unshift("[ST]");
        return console.debug.apply(this, msg);
      }

      warn(...msg) {
        msg.unshift(new Date);
        msg.unshift("[ST]");
        return console.warn.apply(this, msg);
      }

      error(...msg) {
        msg.unshift(new Date);
        msg.unshift("[ST]");
        return console.error.apply(this, msg);
      }

      constructor(opts = {}) {
        var base, base1;
        this.opts = opts;
        // set process title
        process.title = 'synctube-server';
        if ((base = this.opts).debug == null) {
          base.debug = false;
        }
        if ((base1 = this.opts).ws_port == null) {
          base1.ws_port = 1337; // Don't forget to change in client as well
        }
        this.clients = [];
        this.channels = {};
      }

      listen() {
        if (this.http) {
          throw "HTTP server is already bound!";
        }
        this.debug("Creating HTTP server...");
        this.http = http.createServer((...a) => {
          return this.handleHTTPRequest(...a);
        });
        this.debug(`Binding HTTP/WS server on port ${this.opts.ws_port}...`);
        this.http.listen(this.opts.ws_port, () => {
          return this.debug(`HTTP/WS server is listening on port ${this.opts.ws_port}!`);
        });
        // create WS socket server
        this.ws = new webSocketServer({
          httpServer: this.http
        });
        return this.ws.on("request", (request) => {
          return this.handleWSRequest(request);
        });
      }

      htmlEntities(str) {
        return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
      }

      delay(ms, func) {
        return setTimeout(func, ms);
      }

      eachClient(method, ...args) {
        var c, j, len, ref, results;
        ref = this.clients;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          results.push(typeof c[method] === "function" ? c[method](...args) : void 0);
        }
        return results;
      }

      handleHTTPRequest(request, response) {
        var file, type;
        if (this.SERVE_STATIC.indexOf(request.url) > -1) {
          file = request.url;
          if (file === "/") {
            file = "/index.html";
          }
          file = `.${file}`;
          type = "text/html";
          if (file.slice(-3) === ".js") {
            type = "application/javascript";
          }
          if (fs.existsSync(file)) {
            this.debug(`200: served ${file} (${type}) IP: ${request.connection.remoteAddress}`);
            response.writeHead(200, {
              'Content-Type': 'text/html'
            });
            return response.end(fs.readFileSync(file));
          } else {
            this.warn(`404: Not Found (${request.url}) IP: ${request.connection.remoteAddress}`);
            response.writeHead(404, {
              'Content-Type': 'text/plain'
            });
            return response.end("Error 404: Not Found");
          }
        } else {
          this.warn(`400: Bad Request (${request.url}) IP: ${request.connection.remoteAddress}`);
          response.writeHead(400, {
            'Content-Type': 'text/plain'
          });
          return response.end("Error 400: Bad Request");
        }
      }

      handleWSRequest(request) {
        var client;
        client = new Client(this);
        return client.accept(request).listen();
      }

      handleMessage(client, message, msg) {
        var m;
        if (m = msg.match(/!packet:(.+)/i)) {
          return this.SCMD_packet(client, m[1]);
        }
        if (m = msg.match(/\/invoke\s([^\s]+)(?:\s(.+))?/i)) {
          return this.SCMD_invoke(client, m[1], m[2]);
        }
        if (msg.match(/\/rename/i)) {
          return this.SCMD_rename(client);
        }
        if (m = msg.match(/\/restart/i)) {
          return this.SCMD_restart(client);
        }
        if (m = msg.match(/\/retry/i)) {
          return this.SCMD_retry(client);
        }
        if (m = msg.match(/\/control(?:\s([^\s]+)(?:\s(.+))?)?/i)) {
          return this.SCMD_control(client, m[1], m[2]);
        }
        if (m = msg.match(/\/join\s([^\s]+)/i)) {
          return this.SCMD_join(client, m[1]);
        }
        return false;
      }

      SCMD_packet(client, jdata) {
        var ch, error, json, ref, ref1, ref2;
        try {
          json = JSON.parse(jdata);
        } catch (error1) {
          error = error1;
          this.error("Invalid JSON", jdata, error);
          return;
        }
        client.lastPacket = new Date;
        console.log(1, client.index, (ref = client.state) != null ? ref.state : void 0);
        if (!client.state || (JSON.stringify(client.state) !== jdata)) {
          ch = client.subscribed;
          console.log(2, client.index, (ref1 = client.state) != null ? ref1.state : void 0, json.state, ["playing", "buffering", "cued", "ready"].indexOf((ref2 = client.state) != null ? ref2.state : void 0));
          ch.updateDesired(client, json);
          console.log("desired", ch.desired.state, "state", ch.playVideo);
          ch[`${ch.desired.state}Video`](client);
          client.state = json;
          if (ch = client.subscribed) {
            ch.broadcastCode(client, "update_single_subscriber", {
              channel: ch.name,
              data: ch.getSubscriberData(client, client, client.index)
            });
          }
        }
        return true;
      }

      SCMD_invoke(client, which, args) {
        args || (args = "{}");
        client.sendCode(which, JSON.parse(args));
        client.ack();
        return true;
      }

      SCMD_rename(client) {
        client.sendCode("require_username", {
          autofill: false
        });
        client.old_name = client.name;
        client.name = null;
        client.sendSystemMessage("Tell me your new username!");
        client.ack();
        return true;
      }

      SCMD_restart(client) {
        client.sendSystemMessage("See ya!");
        throw "bye";
        //@delay 1000, => client.sendCode "navigate", reload: true
        return true;
      }

      SCMD_retry(client) {
        var ch;
        if (!(ch = client.subscribed)) {
          return;
        }
        ch.revokeControl(client);
        ch.unsubscribe(client);
        ch.subscribe(client);
        return client.ack();
      }

      SCMD_control(client, name, password) {
        var channel, chname, ref;
        chname = this.htmlEntities(name || ((ref = client.subscribed) != null ? ref.name : void 0) || "");
        if (!chname) {
          client.sendSystemMessage("Channel name required", COLORS.red);
          return client.ack();
        }
        if (channel = this.channels[chname]) {
          if (channel.control.indexOf(client) > -1 && password === "delete") {
            channel.destroy(client);
            return client.ack();
          } else {
            if (channel.password === password) {
              channel.subscribe(client);
              channel.grantControl(client);
            } else {
              client.sendSystemMessage("Password incorrect", COLORS.red);
            }
          }
        } else {
          this.channels[chname] = new Channel(this, chname, password);
          client.sendSystemMessage("Channel created!", COLORS.green);
          this.channels[chname].subscribe(client);
          this.channels[chname].grantControl(client);
        }
        return client.ack();
      }

      SCMD_join(client, chname) {
        var channel;
        if (channel = this.channels[chname]) {
          channel.subscribe(client);
        } else {
          client.sendSystemMessage("I don't know about this channel, sorry!");
          client.sendSystemMessage(`<small>You can create it with <strong>/control ${this.htmlEntities(chname)} [password]</strong></small>`, COLORS.info);
        }
        return client.ack();
      }

    };

    SyncTubeServer.prototype.SERVE_STATIC = ["/", "/favicon.ico", "/dist/client.js"];

    SyncTubeServer.prototype.PROTECTED_NAMES = ["admin", "system"];

    SyncTubeServer.prototype.DEFAULT_VIDEO = "6Dh-RL__uN4";

    SyncTubeServer.prototype.DEFAULT_AUTOPLAY = false;

    Channel = class Channel {
      debug(...a) {
        return this.server.debug(`[${this.name}]`, ...a);
      }

      warn(...a) {
        return this.server.warn(`[${this.name}]`, ...a);
      }

      error(...a) {
        return this.server.error(`[${this.name}]`, ...a);
      }

      constructor(server1, name1, password1) {
        this.server = server1;
        this.name = name1;
        this.password = password1;
        this.control = [];
        this.subscribers = [];
        this.queue = [];
        this.playlist = [];
        this.playlist_index = 0;
        this.desired = {
          url: null,
          time: 0,
          state: "pause"
        };
      }

      handleMessage(client, message, msg) {
        return this.broadcast(client, msg, null, (this.control.indexOf(client) > -1 ? COLORS.red : null));
      }

      broadcast(client, message, color, client_color, sendToAuthor = true) {
        var c, j, len, ref, results;
        ref = this.subscribers;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          if (c === client && !sendToAuthor) {
            continue;
          }
          results.push(c.sendMessage(message, color, client.name, client_color || (client != null ? client.color : void 0)));
        }
        return results;
      }

      broadcastCode(client, type, data, sendToAuthor = true) {
        var c, j, len, ref, results;
        ref = this.subscribers;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          if (c === client && !sendToAuthor) {
            continue;
          }
          results.push(c.sendCode(type, data));
        }
        return results;
      }

      updateSubscriberList(client) {
        return this.broadcastCode(client, "subscriber_list", {
          channel: this.name,
          subscribers: this.getSubscriberList(client)
        });
      }

      updateDesired(client) {
        var ref, ref1, ref2;
        this.desired.url = (ref = client.state) != null ? ref.url : void 0;
        this.desired.state = ["playing", "buffering"].indexOf((ref1 = client.state) != null ? ref1.state : void 0) > -1 ? "play" : "pause";
        return this.desired.time = ((ref2 = client.state) != null ? ref2.seek : void 0) || 0;
      }

      getSubscriberList(client) {
        var c, i, j, len, list, ref;
        list = [];
        ref = this.subscribers;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          c = ref[i];
          list.push(this.getSubscriberData(client, c, i));
        }
        return list;
      }

      getSubscriberData(client, sub, index) {
        var data, leader, ref, ref1, ref2, ref3, seekdiff;
        data = {
          index: sub.index,
          name: sub.name,
          control: this.control.indexOf(sub) > -1,
          isyou: client === sub,
          drift: 0,
          state: sub.state || {}
        };
        // calculcate drift
        leader = this.control[0];
        if (((ref = sub.state) != null ? ref.seek : void 0) && ((leader != null ? (ref1 = leader.state) != null ? ref1.seek : void 0 : void 0) != null)) {
          seekdiff = (leader != null ? (ref2 = leader.state) != null ? ref2.seek : void 0 : void 0) - client.state.seek;
          if (leader.lastPacket && client.lastPacket) {
            seekdiff -= (leader.lastPacket - client.lastPacket) / 1000;
          }
          data.drift = seekdiff.toFixed(3);
          if (data.drift === "0.000") {
            data.drift = 0;
          }
        }
        data.progress = data.state.state || "uninitialized";
        switch ((ref3 = data.state) != null ? ref3.state : void 0) {
          case "unstarted":
            data.icon = "cog";
            data.icon_class = "text-muted";
            break;
          case "ended":
            data.icon = "stop";
            data.icon_class = "text-danger";
            break;
          case "playing":
            data.icon = "play";
            data.icon_class = "text-success";
            break;
          case "paused":
            data.icon = "pause";
            data.icon_class = "text-warning";
            break;
          case "buffering":
            data.icon = "spinner";
            data.icon_class = "text-warning";
            break;
          case "cued":
            data.icon = "eject";
            data.icon_class = "text-muted";
            break;
          case "ready":
            data.icon = "check-square-o";
            data.icon_class = "text-muted";
            break;
          default:
            data.icon = "cog";
            data.icon_class = "text-danger";
        }
        return data;
      }

      pauseVideo(client, sendMessage = true) {
        var ref;
        if (!(this.control.indexOf(client) > -1)) {
          return;
        }
        this.broadcastCode(client, "video_action", {
          action: "pause"
        });
        if (((ref = client.state) != null ? ref.seek : void 0) != null) {
          return this.broadcastCode(client, "video_action", {
            action: "seek",
            to: client.state.seek
          }, true);
        }
      }

      playVideo(client, sendMessage = true) {
        if (!(this.control.indexOf(client) > -1)) {
          return;
        }
        return this.broadcastCode(client, "video_action", {
          action: "resume"
        });
      }

      grantControl(client, sendMessage = true) {
        if (this.control.indexOf(client) > -1) {
          return;
        }
        this.control.push(client);
        client.control = this;
        if (sendMessage) {
          client.sendSystemMessage(`You are in control of ${this.name}!`, COLORS.green);
        }
        client.sendCode("taken_control", {
          channel: this.name
        });
        this.updateSubscriberList(client);
        return this.debug(`granted control to client #${client.index}(${client.ip})`);
      }

      revokeControl(client, sendMessage = true, reason = null) {
        if (this.control.indexOf(client) === -1) {
          return;
        }
        this.control.splice(this.control.indexOf(client), 1);
        client.control = null;
        if (sendMessage) {
          client.sendSystemMessage(`You lost control of ${this.name}${(reason ? ` (${reason})` : "")}!`, COLORS.red);
        }
        client.sendCode("lost_control", {
          channel: this.name
        });
        this.updateSubscriberList(client);
        return this.debug(`revoked control from client #${client.index}(${client.ip})`);
      }

      subscribe(client, sendMessage = true) {
        if (this.subscribers.indexOf(client) > -1) {
          return;
        }
        this.subscribers.push(client);
        client.subscribed = this;
        client.state = {};
        if (sendMessage) {
          client.sendSystemMessage(`You joined ${this.name}!`, COLORS.green);
        }
        client.sendCode("subscribe", {
          channel: this.name
        });
        client.sendCode("load_video", {
          ytid: this.server.DEFAULT_VIDEO,
          cue: !this.server.DEFAULT_AUTOPLAY
        });
        this.broadcast(client, "<i>joined the party!</i>", COLORS.green, COLORS.muted, false);
        this.updateSubscriberList(client);
        return this.debug(`subscribed client #${client.index}(${client.ip}) to channel ${this.name}`);
      }

      unsubscribe(client, sendMessage = true, reason = null) {
        if (this.subscribers.indexOf(client) === -1) {
          return;
        }
        this.subscribers.splice(this.subscribers.indexOf(client), 1);
        client.subscribed = null;
        client.state = {};
        if (sendMessage) {
          client.sendSystemMessage(`You left ${this.name}${(reason ? ` (${reason})` : "")}!`, COLORS.red);
        }
        client.sendCode("unsubscribe", {
          channel: this.name
        });
        this.broadcast(client, "<i>left the party :(</i>", COLORS.red, COLORS.muted, false);
        this.updateSubscriberList(client);
        return this.debug(`unsubscribed client #${client.index}(${client.ip}) from channel ${this.name}`);
      }

      destroy(client, sendMessage = true) {
        var c, j, k, len, len1, ref, ref1;
        this.debug(`channel deleted by ${client.name}[${client.ip}] (${this.subscribers.length} subscribers)`);
        ref = this.subscribers;
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          this.unsubscribe(c, true, "channel deleted");
        }
        ref1 = this.control;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          c = ref1[k];
          this.revokeControl(c, true, `channel deleted by ${client.name}[${client.ip}]`);
        }
        return delete this.server.channels[this.name];
      }

    };

    Client = class Client {
      debug(...a) {
        return this.server.debug(`[#${this.index}]`, ...a);
      }

      warn(...a) {
        return this.server.warn(`[#${this.index}]`, ...a);
      }

      error(...a) {
        return this.server.error(`[#${this.index}]`, ...a);
      }

      constructor(server1) {
        this.server = server1;
        this.index = -1;
        if (this.name == null) {
          this.name = null;
        }
        this.control = null;
        this.subscribed = null;
      }

      accept(request1) {
        this.request = request1;
        this.debug(`Accepting connection from origin ${this.request.origin}`);
        this.connection = this.request.accept(null, this.request.origin);
        this.ip = this.connection.remoteAddress;
        this.index = this.server.clients.push(this) - 1;
        this.connection.on("close", () => {
          return this.disconnect();
        });
        this.debug(`Connection accepted (${this.index}): ${this.ip}`);
        this.sendCode("require_username");
        return this;
      }

      listen() {
        this.connection.on("message", (message) => {
          var msg, ref, ref1;
          msg = message.utf8Data;
          if (message.type !== "utf8") {
            this.warn("Received non-utf8 data", message);
            return;
          }
          this.debug(`Received message from ${this.ip}: ${msg}`);
          if (this.name) {
            return this.server.handleMessage(this, message, msg) || ((ref = this.control) != null ? ref.handleMessage(this, message, msg) : void 0) || ((ref1 = this.subscribed) != null ? ref1.handleMessage(this, message, msg) : void 0);
          } else {
            return this.setUsername(msg);
          }
        });
        return this;
      }

      disconnect() {
        var ref, ref1;
        this.debug(`Peer ${this.ip} disconnected.`);
        if ((ref = this.control) != null) {
          if (typeof ref.revokeControl === "function") {
            ref.revokeControl(this);
          }
        }
        if ((ref1 = this.subscribed) != null) {
          if (typeof ref1.unsubscribe === "function") {
            ref1.unsubscribe(this);
          }
        }
        // delete reference and reindex clients
        this.server.clients.splice(this.index, 1);
        return this.server.eachClient("reindex");
      }

      reindex() {
        var was_index;
        was_index = this.index;
        this.index = this.server.clients.indexOf(this);
        this.debug(`Reindexed client session from ${was_index} to ${this.index}`);
        return this;
      }

      sendCode(type, data = {}) {
        this.connection.sendUTF(JSON.stringify({
          type: "code",
          data: Object.assign({}, data, {
            type: type
          })
        }));
        return this;
      }

      sendMessage(message, color, author, author_color) {
        this.connection.sendUTF(JSON.stringify({
          type: "message",
          data: {
            author: author,
            author_color: author_color,
            text: message,
            text_color: color,
            time: (new Date()).getTime()
          }
        }));
        return this;
      }

      sendSystemMessage(message, color) {
        return this.sendMessage(message, color || COLORS.red, "system", COLORS.red);
      }

      ack() {
        this.sendCode("ack");
        return true;
      }

      setUsername(name) {
        var _name;
        this.name = this.server.htmlEntities(name);
        if (this.server.PROTECTED_NAMES.indexOf(this.name.toLowerCase()) > -1) {
          this.name = null;
          this.sendSystemMessage("This name is not allowed!", COLORS.red);
          this.sendCode("require_username");
        } else {
          if (this.old_name) {
            if (this.subscribed) {
              _name = this.name;
              this.name = this.old_name;
              this.subscribed.broadcast(this, `<i>changed his name to ${_name}</i>`, COLORS.info, COLORS.muted);
              this.name = _name;
            } else {
              this.sendSystemMessage(`You changed your name from ${this.old_name} to ${this.name}!`, COLORS.info);
            }
            this.old_name = null;
          } else {
            this.hello();
          }
        }
        this.sendCode("username", {
          username: this.name
        });
        return this.ack();
      }

      hello() {
        this.sendSystemMessage(`Welcome, ${this.name}!`, COLORS.green);
        this.sendSystemMessage("To create or control a channel type <strong>/control &lt;channel&gt; [password]</strong>", COLORS.info);
        return this.sendSystemMessage("To join an existing channel type <strong>/join &lt;channel&gt;</strong>", COLORS.info);
      }

    };

    return SyncTubeServer;

  }).call(this);

  server = new SyncTubeServer({
    debug: true,
    http_port: 1338
  });

  server.listen();

}).call(this);
