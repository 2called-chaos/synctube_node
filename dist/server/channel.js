// Generated by CoffeeScript 2.3.2
(function() {
  var COLORS, SyncTubeServerChannel;

  COLORS = require("../colors.js");

  exports.Class = SyncTubeServerChannel = class SyncTubeServerChannel {
    debug(...a) {
      return this.server.debug(`[${this.name}]`, ...a);
    }

    warn(...a) {
      return this.server.warn(`[${this.name}]`, ...a);
    }

    error(...a) {
      return this.server.error(`[${this.name}]`, ...a);
    }

    constructor(server, name, password) {
      this.server = server;
      this.name = name;
      this.password = password;
      this.control = [];
      this.host = 0;
      this.subscribers = [];
      this.queue = [];
      this.ready = [];
      this.ready_timeout = null;
      this.playlist = [];
      this.playlist_index = 0;
      this.desired = {
        url: this.server.DEFAULT_VIDEO,
        seek: 0,
        seek_update: new Date,
        state: this.server.DEFAULT_AUTOPLAY ? "play" : "pause"
      };
    }

    handleMessage(client, message, msg) {
      var m;
      if (m = msg.match(/^\/(?:seek)(?:\s([0-9\-+]+))?$/i)) {
        return this.CHSCMD_seek(client, m[1]);
      }
      if (m = msg.match(/^\/(?:p|pause)$/i)) {
        return this.CHSCMD_pause(client);
      }
      if (m = msg.match(/^\/(?:r|resume)$/i)) {
        return this.CHSCMD_resume(client);
      }
      if (m = msg.match(/^\/(?:t|toggle)$/i)) {
        return this.CHSCMD_toggle(client);
      }
      if (m = msg.match(/^\/(?:ready|rdy)$/i)) {
        return this.CHSCMD_ready(client);
      }
      if (m = msg.match(/^\/play\s(.+)$/i)) {
        return this.CHSCMD_play(client, m[1]);
      }
      if (m = msg.match(/^\/host(?:\s(.+))?$/i)) {
        return this.CHSCMD_host(client, m[1]);
      }
      this.broadcast(client, msg, null, (this.control.indexOf(client) > -1 ? COLORS.red : null));
      return client.ack();
    }

    CHSCMD_pause(client) {
      this.desired.state = "pause";
      this.broadcastCode(false, "desired", this.desired);
      return client.ack();
    }

    CHSCMD_resume(client) {
      this.desired.state = "play";
      this.broadcastCode(false, "desired", this.desired);
      return client.ack();
    }

    CHSCMD_toggle(client) {
      this.desired.state = this.desired.state === "play" ? "pause" : "play";
      this.broadcastCode(false, "desired", this.desired);
      return client.ack();
    }

    CHSCMD_seek(client, to) {
      if (to.charAt(0) === "-") {
        to = this.desired.seek - parseFloat(to.slice(1));
      } else if (to.charAt(0) === "+") {
        to = this.desired.seek + parseFloat(to.slice(1));
      } else if (to) {
        to = to;
      } else {
        client.sendSystemMessage("Number required (absolute or +/-)");
        return client.ack();
      }
      this.desired.seek = parseFloat(to);
      this.broadcastCode(false, "video_action", {
        action: "sync"
      });
      this.broadcastCode(false, "desired", Object.assign({}, this.desired, {
        force: true
      }));
      return client.ack();
    }

    CHSCMD_ready(client) {
      this.ready.push(client);
      if (this.ready.length === this.subscribers.length) {
        clearTimeout(this.ready_timeout);
        this.desired.state = "play";
        this.broadcastCode(false, "video_action", {
          action: "play"
        });
      }
      return client.ack();
    }

    CHSCMD_play(client, url) {
      var m;
      if (m = url.match(/([A-Za-z0-9_\-]{11})/)) {
        this.liveVideo(m[1]);
      } else {
        client.sendSystemMessage("I don't recognize this URL/YTID format, sorry");
      }
      return client.ack();
    }

    CHSCMD_host(client, who) {
      var found, j, len, newHost, newHostI, ref, sub, wasHost, wasHostI;
      if (who) {
        found = null;
        ref = this.subscribers;
        for (j = 0, len = ref.length; j < len; j++) {
          sub = ref[j];
          if (sub.name.match(new RegExp(who, "i"))) {
            found = sub;
            break;
          }
        }
        if (found) {
          who = found;
        } else {
          client.sendSystemMessage("Couldn't find the target in channel");
          return client.ack();
        }
      } else {
        who = client;
      }
      if (who === this.control[this.host]) {
        client.sendSystemMessage("Target is already host");
      } else if (this.control.indexOf(who) > -1) {
        this.debug("Switching host to #", who.index);
        wasHostI = this.host;
        wasHost = this.control[wasHostI];
        newHostI = this.control.indexOf(who);
        newHost = this.control[newHostI];
        this.control[wasHostI] = newHost;
        this.control[newHostI] = wasHost;
        this.updateSubscriberList(client);
      } else {
        client.sendSystemMessage("Target is not in control and thereby can't be host");
      }
      //@broadcastCode(false, "desired", @desired)
      return client.ack();
    }

    broadcast(client, message, color, client_color, sendToAuthor = true) {
      var c, j, len, ref, results;
      ref = this.subscribers;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        if (c === client && !sendToAuthor) {
          continue;
        }
        results.push(c.sendMessage(message, color, client.name, client_color || (client != null ? client.color : void 0)));
      }
      return results;
    }

    broadcastCode(client, type, data, sendToAuthor = true) {
      var c, j, len, ref, results;
      ref = this.subscribers;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        if (c === client && !sendToAuthor) {
          continue;
        }
        results.push(c.sendCode(type, data));
      }
      return results;
    }

    updateSubscriberList(client) {
      return this.broadcastCode(client, "subscriber_list", {
        channel: this.name,
        subscribers: this.getSubscriberList(client)
      });
    }

    liveVideo(url, state = "pause") {
      this.desired = {
        url: url,
        seek: 0,
        state: state
      };
      this.ready = [];
      this.broadcastCode(false, "desired", this.desired);
      // start after grace period
      return this.ready_timeout = setTimeout((() => {
        this.desired.state = "play";
        return this.broadcastCode(false, "video_action", {
          action: "play"
        });
      }), 2000);
    }

    getSubscriberList(client) {
      var c, i, j, len, list, ref;
      list = [];
      ref = this.subscribers;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        c = ref[i];
        list.push(this.getSubscriberData(client, c, i));
      }
      return list;
    }

    getSubscriberData(client, sub, index) {
      var data, leader, ref, ref1, ref2, ref3, seekdiff;
      data = {
        index: sub.index,
        name: sub.name,
        control: this.control.indexOf(sub) > -1,
        isHost: this.control[this.host] === sub,
        isyou: client === sub,
        drift: 0,
        state: sub.state || {}
      };
      // calculcate drift
      leader = this.control[0];
      if (((ref = sub.state) != null ? ref.seek : void 0) && ((leader != null ? (ref1 = leader.state) != null ? ref1.seek : void 0 : void 0) != null)) {
        seekdiff = (leader != null ? (ref2 = leader.state) != null ? ref2.seek : void 0 : void 0) - client.state.seek;
        if (leader.lastPacket && client.lastPacket) {
          seekdiff -= (leader.lastPacket - client.lastPacket) / 1000;
        }
        data.drift = seekdiff.toFixed(3);
        if (data.drift === "0.000") {
          data.drift = 0;
        }
      }
      data.progress = data.state.state || "uninitialized";
      switch ((ref3 = data.state) != null ? ref3.state : void 0) {
        case "unstarted":
          data.icon = "cog";
          data.icon_class = "text-muted";
          break;
        case "ended":
          data.icon = "stop";
          data.icon_class = "text-danger";
          break;
        case "playing":
          data.icon = "play";
          data.icon_class = "text-success";
          break;
        case "paused":
          data.icon = "pause";
          data.icon_class = "text-warning";
          break;
        case "buffering":
          data.icon = "spinner";
          data.icon_class = "text-warning";
          break;
        case "cued":
          data.icon = "eject";
          data.icon_class = "text-muted";
          break;
        case "ready":
          data.icon = "check-square-o";
          data.icon_class = "text-muted";
          break;
        default:
          data.icon = "cog";
          data.icon_class = "text-danger";
      }
      return data;
    }

    pauseVideo(client, sendMessage = true) {
      var ref;
      if (!(this.control.indexOf(client) > -1)) {
        return;
      }
      this.broadcastCode(client, "video_action", {
        action: "pause"
      }, {}, false);
      if (((ref = client.state) != null ? ref.seek : void 0) != null) {
        return this.broadcastCode(client, "video_action", {
          action: "seek",
          to: client.state.seek,
          paused: true
        }, false);
      }
    }

    playVideo(client, sendMessage = true) {
      if (!(this.control.indexOf(client) > -1)) {
        return;
      }
      return this.broadcastCode(client, "video_action", {
        action: "resume"
      }, false);
    }

    grantControl(client, sendMessage = true) {
      if (this.control.indexOf(client) > -1) {
        return;
      }
      this.control.push(client);
      client.control = this;
      if (sendMessage) {
        client.sendSystemMessage(`You are in control of ${this.name}!`, COLORS.green);
      }
      client.sendCode("taken_control", {
        channel: this.name
      });
      this.updateSubscriberList(client);
      return this.debug(`granted control to client #${client.index}(${client.ip})`);
    }

    revokeControl(client, sendMessage = true, reason = null) {
      if (this.control.indexOf(client) === -1) {
        return;
      }
      this.control.splice(this.control.indexOf(client), 1);
      client.control = null;
      if (sendMessage) {
        client.sendSystemMessage(`You lost control of ${this.name}${(reason ? ` (${reason})` : "")}!`, COLORS.red);
      }
      client.sendCode("lost_control", {
        channel: this.name
      });
      this.updateSubscriberList(client);
      return this.debug(`revoked control from client #${client.index}(${client.ip})`);
    }

    subscribe(client, sendMessage = true) {
      if (this.subscribers.indexOf(client) > -1) {
        return;
      }
      this.subscribers.push(client);
      client.subscribed = this;
      client.state = {};
      if (sendMessage) {
        client.sendSystemMessage(`You joined ${this.name}!`, COLORS.green);
      }
      client.sendCode("subscribe", {
        channel: this.name
      });
      client.sendCode("desired", this.desired);
      this.broadcast(client, "<i>joined the party!</i>", COLORS.green, COLORS.muted, false);
      this.updateSubscriberList(client);
      return this.debug(`subscribed client #${client.index}(${client.ip}) to channel ${this.name}`);
    }

    unsubscribe(client, sendMessage = true, reason = null) {
      if (this.subscribers.indexOf(client) === -1) {
        return;
      }
      this.subscribers.splice(this.subscribers.indexOf(client), 1);
      client.subscribed = null;
      client.state = {};
      if (sendMessage) {
        client.sendSystemMessage(`You left ${this.name}${(reason ? ` (${reason})` : "")}!`, COLORS.red);
      }
      client.sendCode("unsubscribe", {
        channel: this.name
      });
      this.broadcast(client, "<i>left the party :(</i>", COLORS.red, COLORS.muted, false);
      this.updateSubscriberList(client);
      return this.debug(`unsubscribed client #${client.index}(${client.ip}) from channel ${this.name}`);
    }

    destroy(client, sendMessage = true) {
      var c, j, k, len, len1, ref, ref1;
      this.debug(`channel deleted by ${client.name}[${client.ip}] (${this.subscribers.length} subscribers)`);
      ref = this.subscribers;
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        this.unsubscribe(c, true, "channel deleted");
      }
      ref1 = this.control;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        c = ref1[k];
        this.revokeControl(c, true, `channel deleted by ${client.name}[${client.ip}]`);
      }
      return delete this.server.channels[this.name];
    }

  };

}).call(this);
