// Generated by CoffeeScript 2.3.2
(function() {
  var COLORS, Channel, Client, ShellQuote, UTIL, XClient, x,
    splice = [].splice;

  COLORS = require("./colors.js");

  UTIL = require("./util.js");

  Channel = require("./channel.js").Class;

  Client = require("./client.js").Class;

  XClient = require("./client.js").Class;

  ShellQuote = require("shell-quote");

  x = module.exports = {
    handleMessage: function(server, client, message, msg) {
      var ch, chunks, cmd, err, j, len, m, ref, ref1, ref2;
      try {
        if (m = msg.match(/^!packet:(.+)$/i)) {
          return this.Server["packet"].call(server, client, m[1]);
        }
        chunks = [];
        cmd = null;
        if (msg && msg.charAt(0) === "/") {
          ref = ShellQuote.parse(msg.substr(1));
          for (j = 0, len = ref.length; j < len; j++) {
            x = ref[j];
            chunks.push(typeof x === "string" ? x : x.pattern);
          }
          cmd = chunks.shift();
        }
        if (cmd && ((ref1 = this.Server[cmd]) != null ? ref1.call(server, client, ...chunks) : void 0)) {
          return;
        }
        if (ch = client.subscribed) {
          if (cmd && ((ref2 = this.Channel[cmd]) != null ? ref2.call(ch, client, ...chunks) : void 0)) {
            return;
          }
          ch.broadcast(client, msg, null, ch.clientColor(client));
          return client.ack();
        }
        return client.ack();
      } catch (error1) {
        err = error1;
        server.error(err);
        client.sendSystemMessage("Sorry, the server encountered an error");
        return client.ack();
      }
    },
    addCommand: function(parent, ...cmds) {
      var _cmd, j, len, proc, ref, results;
      ref = cmds, [...cmds] = ref, [proc] = splice.call(cmds, -1);
      results = [];
      for (j = 0, len = cmds.length; j < len; j++) {
        _cmd = cmds[j];
        results.push((function(cmd) {
          return x[parent][cmd] = proc;
        })(_cmd));
      }
      return results;
    },
    Server: {},
    Channel: {}
  };

  x.addCommand("Server", "clear", function(client) {
    client.sendCode("ui_clear", {
      component: "chat"
    });
    return client.ack();
  });

  x.addCommand("Server", "packet", function(client, jdata) {
    var ch, error, json, seek_was;
    try {
      json = JSON.parse(jdata);
    } catch (error1) {
      error = error1;
      this.error("Invalid JSON", jdata, error);
      return;
    }
    client.lastPacket = new Date;
    ch = client.subscribed;
    if (ch && (!client.state || (JSON.stringify(client.state) !== jdata))) {
      json.time = new Date;
      if ((json.seek != null) && (json.playtime != null)) {
        json.timestamp = UTIL.videoTimestamp(json.seek, json.playtime);
      }
      client.state = json;
      ch.broadcastCode(client, "update_single_subscriber", {
        channel: ch.name,
        data: ch.getSubscriberData(client, client, client.index)
      });
      if (client === ch.control[ch.host] && ch.desired.url === json.url) {
        seek_was = ch.desired.seek;
        if (json.state === "ended") {
          ch.desired.state = json.state;
        }
        ch.desired.seek = json.seek;
        ch.desired.seek_update = new Date();
        ch.broadcastCode(false, "desired", Object.assign({}, ch.desired, {
          force: Math.abs(ch.desired.seek - seek_was) > (this.opts.packetInterval + 0.75)
        }));
      }
    } else {
      if (ch) {
        client.sendCode("desired", ch.desired);
      }
    }
    return true;
  });

  x.addCommand("Server", "join", function(client, chname) {
    var channel;
    if (channel = this.channels[chname]) {
      channel.subscribe(client);
    } else if (chname) {
      client.sendSystemMessage("I don't know about this channel, sorry!");
      client.sendSystemMessage(`<small>You can create it with <strong>/control ${UTIL.htmlEntities(chname)} [password]</strong></small>`, COLORS.info);
    } else {
      client.sendSystemMessage("Usage: /join &lt;channel&gt;");
    }
    return client.ack();
  });

  x.addCommand("Server", "control", function(client, name, password) {
    var channel, chname, ref;
    chname = UTIL.htmlEntities(name || ((ref = client.subscribed) != null ? ref.name : void 0) || "");
    if (!chname) {
      client.sendSystemMessage("Channel name required", COLORS.red);
      return client.ack();
    }
    if (channel = this.channels[chname]) {
      if (channel.control.indexOf(client) > -1 && password === "delete") {
        channel.destroy(client);
        return client.ack();
      } else {
        if (channel.password === password) {
          channel.subscribe(client);
          channel.grantControl(client);
        } else {
          client.sendSystemMessage("Password incorrect", COLORS.red);
        }
      }
    } else {
      this.channels[chname] = new Channel(this, chname, password);
      client.sendSystemMessage("Channel created!", COLORS.green);
      this.channels[chname].subscribe(client);
      this.channels[chname].grantControl(client);
    }
    return client.ack();
  });

  x.addCommand("Server", "dc", "disconnect", function(client) {
    client.sendSystemMessage("disconnecting...");
    client.sendCode("disconnected");
    return client.connection.close();
  });

  x.addCommand("Server", "rename", function(client, ...name_parts) {
    var new_name;
    if (new_name = name_parts.join(" ")) {
      client.old_name = client.name;
      client.setUsername(new_name);
    } else {
      client.sendCode("require_username", {
        maxLength: this.opts.nameMaxLength,
        autofill: false
      });
      client.old_name = client.name;
      client.name = null;
      client.sendSystemMessage("Tell me your new username!");
    }
    return client.ack();
  });

  x.addCommand("Server", "system", function(client, subaction, ...args) {
    var amsg, c, ch, channel, detail, i, iargs, j, len, m, msg, nulled, reason, ref, target, time, what, which, who;
    if (!client.isSystemAdmin) {
      if (subaction === "auth") {
        if (UTIL.argsToStr(args) === this.opts.systemPassword) {
          client.isSystemAdmin = true;
          client.sendSystemMessage("Authenticated successfully!", COLORS.green);
        } else {
          client.sendSystemMessage("invalid password");
        }
      } else {
        client.sendSystemMessage("system commands require you to `/system auth &lt;syspw&gt;` first!");
      }
      return client.ack();
    }
    switch (subaction) {
      case "restart":
        if (reason = UTIL.argsToStr(args)) {
          this.eachClient("sendSystemMessage", `Server restart: ${reason}`);
        }
        client.sendSystemMessage("See ya!");
        throw "bye";
        //UTIL.delay 1000, => client.sendCode "navigate", reload: true
        return true;
      case "gracefulRestart":
        if (args[0] === "cancel") {
          if (this.pendingRestart != null) {
            this.eachClient("sendSystemMessage", "Restart canceled");
            this.pendingRestart = null;
            this.pendingRestartReason = null;
            clearTimeout(this.pendingRestartTimeout);
          } else {
            client.sendSystemMessage("No pending restart");
          }
        } else {
          time = new Date((new Date).getTime() + UTIL.timestamp2Seconds(args.shift()) * 1000);
          clearTimeout(this.pendingRestartTimeout);
          this.pendingRestart = time;
          this.pendingRestartReason = UTIL.argsToStr(args);
          this.handlePendingRestart(true);
        }
        break;
      case "message":
        this.eachClient("sendSystemMessage", `${UTIL.argsToStr(args)}`);
        break;
      case "chmessage":
        channel = args.shift();
        if (ch = this.channels[channel]) {
          ch.broadcast({
            name: "system"
          }, UTIL.argsToStr(args), COLORS.red, COLORS.red);
        } else {
          client.sendSystemMessage("The channel could not be found!");
        }
        break;
      case "chkill":
        channel = args.shift();
        if (ch = this.channels[channel]) {
          ch.destroy(client, UTIL.argsToStr(args));
          client.sendSystemMessage("Channel destroyed!");
        } else {
          client.sendSystemMessage("The channel could not be found!");
        }
        break;
      case "status":
        client.sendSystemMessage("======================");
        nulled = 0;
        ref = this.clients;
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          if (c === null) {
            nulled += 1;
          }
        }
        client.sendSystemMessage(`Running with pid ${process.pid} since ${UTIL.secondsToTimestamp(process.uptime())} (on ${process.platform})`);
        client.sendSystemMessage(`${this.clients.length - nulled} active sessions (${this.clients.length} total, ${nulled}/${this.opts.sessionReindex} nulled)`);
        client.sendSystemMessage(`${UTIL.microToHuman(process.cpuUsage().user)}/${UTIL.microToHuman(process.cpuUsage().system)} CPU (usr/sys)`);
        client.sendSystemMessage(`${UTIL.bytesToHuman(process.memoryUsage().rss)} memory (RSS)`);
        client.sendSystemMessage("======================");
        break;
      case "invoke":
        target = client;
        if ((i = args.indexOf("-t")) > -1 || (i = args.indexOf("--target")) > -1) {
          Client = require("./client.js").Class;
          x = args.splice(i, 2);
          who = typeof x[1] === "string" ? x[1] : x[1].pattern;
          target = Client.find(client, who, this.clients);
        }
        if (!target) {
          return true;
        }
        which = args.shift();
        iargs = UTIL.argsToStr(args) || "{}";
        client.sendCode(which, JSON.parse(iargs));
        break;
      case "kick":
        who = args.shift();
        target = Client = require("./client.js").Class.find(client, who, this.clients);
        if (!target) {
          return true;
        }
        amsg = `Kicked #${target.index} ${target.name} (${target.ip}) from server`;
        this.info(amsg);
        client.sendSystemMessage(amsg);
        msg = `You got kicked from the server${((m = UTIL.argsToStr(args)) ? ` (${m})` : "")}`;
        target.sendCode("session_kicked", {
          reason: msg
        });
        target.sendSystemMessage(msg);
        target.connection.close();
        break;
      case "dump":
        what = args[0];
        detail = args[1];
        if (what === "client") {
          console.log(detail ? this.clients[parseInt(detail)] : client);
        } else if (what === "channel") {
          console.log(detail ? this.channels[detail] : client.subscribed ? client.subscribed : this.channels);
        }
    }
    return client.ack();
  });

  x.addCommand("Channel", "retry", function(client) {
    var ch;
    if (!(ch = client.subscribed)) {
      return;
    }
    ch.revokeControl(client);
    ch.unsubscribe(client);
    ch.subscribe(client);
    return client.ack();
  });

  x.addCommand("Channel", "p", "pause", function(client) {
    if (!(this.control.indexOf(client) > -1)) {
      return client.permissionDenied("pause");
    }
    this.desired.state = "pause";
    this.broadcastCode(false, "desired", this.desired);
    return client.ack();
  });

  x.addCommand("Channel", "r", "resume", function(client) {
    if (!(this.control.indexOf(client) > -1)) {
      return client.permissionDenied("resume");
    }
    this.desired.state = "play";
    this.broadcastCode(false, "desired", this.desired);
    return client.ack();
  });

  x.addCommand("Channel", "t", "toggle", function(client) {
    if (!(this.control.indexOf(client) > -1)) {
      return client.permissionDenied("toggle");
    }
    this.desired.state = this.desired.state === "play" ? "pause" : "play";
    this.broadcastCode(false, "desired", this.desired);
    return client.ack();
  });

  x.addCommand("Channel", "s", "seek", function(client, to) {
    if (!(this.control.indexOf(client) > -1)) {
      return client.permissionDenied("seek");
    }
    if ((to != null ? to.charAt(0) : void 0) === "-") {
      to = this.desired.seek - UTIL.timestamp2Seconds(to.slice(1));
    } else if ((to != null ? to.charAt(0) : void 0) === "+") {
      to = this.desired.seek + UTIL.timestamp2Seconds(to.slice(1));
    } else if (to) {
      to = UTIL.timestamp2Seconds(to);
    } else {
      client.sendSystemMessage("Number required (absolute or +/-)");
      return client.ack();
    }
    this.desired.seek = parseFloat(to);
    if (this.desired.state === "ended") {
      this.desired.state = "play";
    }
    this.broadcastCode(false, "desired", Object.assign({}, this.desired, {
      force: true
    }));
    return client.ack();
  });

  x.addCommand("Channel", "sync", "resync", function(client, ...args) {
    var found, i, instant, j, len, t, target, who;
    target = [client];
    instant = false;
    if ((i = args.indexOf("-i")) > -1 || (i = args.indexOf("--instant")) > -1) {
      args.splice(i, 1);
      instant = true;
    }
    if ((i = args.indexOf("-t")) > -1 || (i = args.indexOf("--target")) > -1) {
      x = args.splice(i, 2);
      if (!(this.control.indexOf(client) > -1)) {
        return client.permissionDenied("resync-target");
      }
      Client = require("./client.js").Class;
      who = x[1];
      found = Client.find(client, who, this.subscribers);
      target = found === client ? false : [found];
    }
    if ((i = args.indexOf("-a")) > -1 || (i = args.indexOf("--all")) > -1) {
      args.splice(i, 1);
      if (!(this.control.indexOf(client) > -1)) {
        return client.permissionDenied("resync-all");
      }
      target = this.subscribers;
    }
    if (target && target.length) {
      for (j = 0, len = target.length; j < len; j++) {
        t = target[j];
        if (instant) {
          if (t != null) {
            t.sendCode("desired", Object.assign({}, this.desired, {
              force: true
            }));
          }
        } else {
          if (t != null) {
            t.sendCode("video_action", {
              action: "sync"
            });
          }
        }
      }
    } else {
      client.sendSystemMessage("Found no targets");
    }
    return client.ack();
  });

  x.addCommand("Channel", "ready", function(client) {
    this.ready.push(client);
    if (this.ready.length === this.subscribers.length) {
      clearTimeout(this.ready_timeout);
      this.desired.state = "play";
      this.broadcastCode(false, "video_action", {
        action: "play"
      });
    }
    return client.ack();
  });

  x.addCommand("Channel", "play", "yt", "youtube", function(client, url) {
    var m;
    if (!(this.control.indexOf(client) > -1)) {
      return client.permissionDenied("play");
    }
    if (m = url.match(/([A-Za-z0-9_\-]{11})/)) {
      this.liveVideo(m[1]);
    } else {
      client.sendSystemMessage("I don't recognize this URL/YTID format, sorry");
    }
    return client.ack();
  });

  x.addCommand("Channel", "loop", function(client, what) {
    if (what || this.control.indexOf(client) > -1) {
      if (!(this.control.indexOf(client) > -1)) {
        return client.permissionDenied("loop");
      }
      what = UTIL.strbool(what, !this.desired.loop);
      if (this.desired.loop === what) {
        client.sendSystemMessage(`Loop is already ${(this.desired.loop ? "enabled" : "disabled")}!`);
      } else {
        this.desired.loop = what;
        this.broadcastCode(false, "desired", this.desired);
        this.broadcast(client, `<strong>${(this.desired.loop ? "enabled" : "disabled")} loop!</strong>`, COLORS.warning, this.clientColor(client));
      }
    } else {
      client.sendSystemMessage(`Loop is currently ${(this.desired.loop ? "enabled" : "disabled")}`, this.desired.loop ? COLORS.green : COLORS.red);
    }
    return client.ack();
  });

  x.addCommand("Channel", "url", "browse", function(client, url, ctype = "HtmlFrame") {
    if (!(this.control.indexOf(client) > -1)) {
      return client.permissionDenied(`browse-${ctype}`);
    }
    this.liveUrl(url, ctype);
    return client.ack();
  });

  x.addCommand("Channel", "img", "image", "pic", "picture", "gif", "png", "jpg", function(client, url) {
    return module.exports.Channel.browse.call(this, client, url, "HtmlImage");
  });

  x.addCommand("Channel", "vid", "video", "mp4", "webp", function(client, url) {
    return module.exports.Channel.browse.call(this, client, url, "HtmlVideo");
  });

  x.addCommand("Channel", "leave", "quit", function(client) {
    var ch;
    if (ch = client.subscribed) {
      ch.unsubscribe(client);
      client.sendCode("desired", {
        ctype: "StuiCreateForm"
      });
    } else {
      client.sendSystemMessage("You are not in any channel!");
    }
    return client.ack();
  });

  x.addCommand("Channel", "password", function(client, new_password, revoke) {
    var ch, cu, j, len, ref;
    if (ch = client.subscribed) {
      if (ch.control.indexOf(client) > -1) {
        if (typeof new_password === "string") {
          ch.password = new_password ? new_password : void 0;
          revoke = UTIL.strbool(revoke, false);
          client.sendSystemMessage(`Password changed${(revoke ? ", revoked all but you" : "")}!`);
          if (revoke) {
            ref = ch.control;
            for (j = 0, len = ref.length; j < len; j++) {
              cu = ref[j];
              if (cu === client) {
                continue;
              }
              ch.revokeControl(cu, true, "channel password changed");
            }
          }
        } else {
          client.sendSystemMessage("New password required! (you can use \"\")");
        }
      } else {
        client.sendSystemMessage("You are not in control!");
      }
    } else {
      client.sendSystemMessage("You are not in any channel!");
    }
    return client.ack();
  });

  x.addCommand("Channel", "kick", function(client, who, ...args) {
    var amsg, ch, m, msg, target;
    if (ch = client.subscribed) {
      if (ch.control.indexOf(client) > -1) {
        target = Client = require("./client.js").Class.find(client, who, ch.subscribers);
        if (!target) {
          return true;
        }
        if (target === client) {
          client.sendSystemMessage("You want to kick yourself?");
          return client.ack();
        }
        amsg = `Kicked #${target.index} ${target.name} (${target.ip}) from channel ${ch.name}`;
        this.info(amsg);
        client.sendSystemMessage(amsg);
        msg = `You got kicked from the channel${((m = UTIL.argsToStr(args)) ? ` (${m})` : "")}`;
        target.sendCode("kicked", {
          reason: msg
        });
        target.sendSystemMessage(msg);
        ch.unsubscribe(target);
      } else {
        client.sendSystemMessage("You are not in control!");
      }
    } else {
      client.sendSystemMessage("You are not in any channel!");
    }
    return client.ack();
  });

  x.addCommand("Channel", "host", function(client, who) {
    var newHost, newHostI, wasHost, wasHostI;
    if (!(this.control.indexOf(client) > -1)) {
      return client.permissionDenied("host");
    }
    if (!(who = this.findClient(client, who))) {
      return false;
    }
    if (who === this.control[this.host]) {
      client.sendSystemMessage(`${(who != null ? who.name : void 0) || "Target"} is already host`);
    } else if (this.control.indexOf(who) > -1) {
      this.debug("Switching host to #", who.index);
      wasHostI = this.host;
      wasHost = this.control[wasHostI];
      newHostI = this.control.indexOf(who);
      newHost = this.control[newHostI];
      this.control[wasHostI] = newHost;
      this.control[newHostI] = wasHost;
      this.updateSubscriberList(client);
    } else {
      client.sendSystemMessage(`${(who != null ? who.name : void 0) || "Target"} is not in control and thereby can't be host`);
    }
    //@broadcastCode(false, "desired", @desired)
    return client.ack();
  });

  x.addCommand("Channel", "grant", function(client, who) {
    if (!(this.control.indexOf(client) > -1)) {
      return client.permissionDenied("grantControl");
    }
    if (!(who = this.findClient(client, who))) {
      return true;
    }
    if (this.control.indexOf(who) > -1) {
      client.sendSystemMessage(`${(who != null ? who.name : void 0) || "Target"} is already in control`);
    } else {
      this.grantControl(who);
      client.sendSystemMessage(`${(who != null ? who.name : void 0) || "Target"} is now in control!`, COLORS.green);
    }
    return client.ack();
  });

  x.addCommand("Channel", "revoke", function(client, who) {
    if (!(this.control.indexOf(client) > -1)) {
      return client.permissionDenied("revokeControl");
    }
    if (!(who = this.findClient(client, who))) {
      return true;
    }
    if (this.control.indexOf(who) > -1) {
      this.revokeControl(who);
      client.sendSystemMessage(`${(who != null ? who.name : void 0) || "Target"} is no longer in control!`, COLORS.green);
    } else {
      client.sendSystemMessage(`${(who != null ? who.name : void 0) || "Target"} was not in control`);
    }
    return client.ack();
  });

}).call(this);
