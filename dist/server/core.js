// Generated by CoffeeScript 2.3.2
(function() {
  // libraries
  var COLORS, Channel, Client, HttpRequest, SyncTubeServer, UTIL, fs, http, webSocketServer;

  fs = require('fs');

  http = require('http');

  webSocketServer = require('websocket').server;

  // internal
  COLORS = require("./colors.js");

  UTIL = require("./util.js");

  Channel = require("./channel.js").Class;

  Client = require("./client.js").Class;

  HttpRequest = require("./http_request.js").Class;

  exports.Class = SyncTubeServer = class SyncTubeServer {
    constructor(opts = {}) {
      this.opts = opts;
      this.root = process.env.ST_ROOT || process.cwd();
      this.loadConfig();
      this.clients = [];
      this.channels = {};
      // set process title
      process.title = "synctube-server";
    }

    loadConfig() {
      if (!fs.existsSync(`${this.root}/config.js`)) {
        fs.copyFileSync(`${this.root}/config.example.js`, `${this.root}/config.js`);
        this.warn("No config file found! Copied config.example.js to config.js");
      }
      this.opts = require(`${this.root}/config.js`);
      if (!this.opts.systemPassword) {
        this.opts.systemPassword = require("crypto").randomBytes(10).toString("hex");
        this.warn("===========================================");
        this.warn("== No system password defined in config, ==");
        this.warn("== a random password will be generated!  ==");
        this.warn("== This will happen every boot, to avoid ==");
        this.warn("== this set a password in your config.js ==");
        this.warn(`== SystemPassword: ${this.opts.systemPassword}  ==`);
        return this.warn("===========================================");
      }
    }

    listen() {
      if (this.http) {
        throw "HTTP server is already bound!";
      }
      this.info("Creating HTTP server...");
      this.http = http.createServer((...a) => {
        return this.handleHTTPRequest(...a);
      });
      this.debug(`Binding HTTP/WS server on port ${this.opts.port}...`);
      this.http.listen(this.opts.port, this.opts.host);
      this.http.on("listening", () => {
        return this.info(`HTTP/WS server is listening on IPv${this.http._connectionKey}`);
      });
      // create WS socket server
      this.ws = new webSocketServer({
        httpServer: this.http
      });
      return this.ws.on("request", (request) => {
        return this.handleWSRequest(request);
      });
    }

    eachClient(method, ...args) {
      var c, i, len, ref, results;
      ref = this.clients;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        results.push(typeof c[method] === "function" ? c[method](...args) : void 0);
      }
      return results;
    }

    nullSession(client, forceReindex) {
      this.clients[client.index] = null;
      return this.cleanupSessions(forceReindex);
    }

    cleanupSessions(force = false) {
      var c, i, j, len, len1, newClients, nulled, ref, ref1;
      if (!force) {
        nulled = 0;
        ref = this.clients;
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          if (c === null) {
            nulled += 1;
          }
        }
        if (nulled >= this.opts.sessionReindex) {
          this.debug(`reindexing sessions (${nulled} nulled sessions)`);
        } else {
          return;
        }
      }
      newClients = [];
      ref1 = this.clients;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        c = ref1[j];
        if (c !== null) {
          newClients.push(c);
        }
      }
      this.clients = newClients;
      return this.eachClient("reindex");
    }

    handleHTTPRequest(request, response) {
      var req;
      req = new HttpRequest(this);
      if (this.opts.answerHttp) {
        return req.accept(request, response);
      } else {
        return req.reject(request, response);
      }
    }

    handleWSRequest(request) {
      var client;
      client = new Client(this);
      return client.accept(request).listen();
    }

    // ===========
    // = Logging =
    // ===========
    debug(...msg) {
      if (!this.opts.debug) {
        return;
      }
      msg.unshift(new Date);
      msg.unshift("[ST-DEBUG]");
      return console.debug.apply(this, msg);
    }

    info(...msg) {
      msg.unshift(new Date);
      msg.unshift("[ST-INFO] ");
      return console.log.apply(this, msg);
    }

    warn(...msg) {
      msg.unshift(new Date);
      msg.unshift("[ST-WARN] ");
      return console.warn.apply(this, msg);
    }

    error(...msg) {
      msg.unshift(new Date);
      msg.unshift("[ST-ERROR]");
      return console.error.apply(this, msg);
    }

    // ===================
    // = Server commands =
    // ===================
    handleMessage(client, message, msg) {
      var m;
      if (m = msg.match(/^!packet:(.+)$/i)) {
        return this.SCMD_packet(client, m[1]);
      }
      if (m = msg.match(/^\/join\s([^\s]+)$/i)) {
        return this.SCMD_join(client, m[1]);
      }
      if (m = msg.match(/^\/control(?:\s([^\s]+)(?:\s(.+))?)?$/i)) {
        return this.SCMD_control(client, m[1], m[2]);
      }
      if (msg.match(/^\/rename$/i)) {
        return this.SCMD_rename(client);
      }
      if (msg.match(/^\/restart$/i)) {
        return this.SCMD_restart(client);
      }
      if (m = msg.match(/^\/invoke\s([^\s]+)(?:\s(.+))?$/i)) {
        return this.SCMD_invoke(client, m[1], m[2]);
      }
      if (m = msg.match(/^\/dump\s([^\s]+)(?:\s(.+))?$/i)) {
        return this.SCMD_dump(client, m[1], m[2]);
      }
      return false;
    }

    SCMD_packet(client, jdata) {
      var ch, error, json, seek_was;
      try {
        json = JSON.parse(jdata);
      } catch (error1) {
        error = error1;
        this.error("Invalid JSON", jdata, error);
        return;
      }
      client.lastPacket = new Date;
      ch = client.subscribed;
      if (ch && (!client.state || (JSON.stringify(client.state) !== jdata))) {
        json.time = new Date;
        if ((json.seek != null) && (json.playtime != null)) {
          json.timestamp = UTIL.videoTimestamp(json.seek, json.playtime);
        }
        client.state = json;
        ch.broadcastCode(client, "update_single_subscriber", {
          channel: ch.name,
          data: ch.getSubscriberData(client, client, client.index)
        });
        if (client === ch.control[ch.host] && ch.desired.url === json.url) {
          seek_was = ch.desired.seek;
          if (json.state === "ended") {
            ch.desired.state = json.state;
          }
          ch.desired.seek = json.seek;
          ch.desired.seek_update = new Date();
          ch.broadcastCode(false, "desired", Object.assign({}, ch.desired, {
            force: Math.abs(ch.desired.seek - seek_was) > (this.opts.packetInterval + 0.75)
          }));
        }
      } else {
        if (ch) {
          client.sendCode("desired", ch.desired);
        }
      }
      return true;
    }

    SCMD_join(client, chname) {
      var channel;
      if (channel = this.channels[chname]) {
        channel.subscribe(client);
      } else {
        client.sendSystemMessage("I don't know about this channel, sorry!");
        client.sendSystemMessage(`<small>You can create it with <strong>/control ${UTIL.htmlEntities(chname)} [password]</strong></small>`, COLORS.info);
      }
      return client.ack();
    }

    SCMD_control(client, name, password) {
      var channel, chname, ref;
      chname = UTIL.htmlEntities(name || ((ref = client.subscribed) != null ? ref.name : void 0) || "");
      if (!chname) {
        client.sendSystemMessage("Channel name required", COLORS.red);
        return client.ack();
      }
      if (channel = this.channels[chname]) {
        if (channel.control.indexOf(client) > -1 && password === "delete") {
          channel.destroy(client);
          return client.ack();
        } else {
          if (channel.password === password) {
            channel.subscribe(client);
            channel.grantControl(client);
          } else {
            client.sendSystemMessage("Password incorrect", COLORS.red);
          }
        }
      } else {
        this.channels[chname] = new Channel(this, chname, password);
        client.sendSystemMessage("Channel created!", COLORS.green);
        this.channels[chname].subscribe(client);
        this.channels[chname].grantControl(client);
      }
      return client.ack();
    }

    SCMD_rename(client) {
      client.sendCode("require_username", {
        maxLength: this.opts.nameMaxLength,
        autofill: false
      });
      client.old_name = client.name;
      client.name = null;
      client.sendSystemMessage("Tell me your new username!");
      return client.ack();
    }

    SCMD_restart(client) {
      client.sendSystemMessage("See ya!");
      throw "bye";
      //UTIL.delay 1000, => client.sendCode "navigate", reload: true
      return true;
    }

    SCMD_invoke(client, which, args) {
      args || (args = "{}");
      client.sendCode(which, JSON.parse(args));
      return client.ack();
    }

    SCMD_dump(client, what, detail) {
      if (what === "client") {
        console.log(detail ? this.clients[parseInt(detail)] : client);
      } else if (what === "channel") {
        console.log(detail ? this.channels[detail] : client.subscribed ? client.subscribed : this.channels);
      }
      return client.ack();
    }

  };

}).call(this);
