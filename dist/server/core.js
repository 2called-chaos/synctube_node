// Generated by CoffeeScript 2.3.2
(function() {
  // libraries
  var COLORS, Channel, Client, Commands, HttpRequest, SyncTubeServer, UTIL, fs, http, webSocketServer;

  fs = require('fs');

  http = require('http');

  webSocketServer = require('websocket').server;

  // internal
  COLORS = require("./colors.js");

  UTIL = require("./util.js");

  Client = require("./client.js").Class;

  Commands = require("./commands.js");

  Channel = require("./channel.js").Class;

  HttpRequest = require("./http_request.js").Class;

  exports.Class = SyncTubeServer = class SyncTubeServer {
    constructor(opts = {}) {
      var i, len, plugin, ref;
      this.opts = opts;
      this.root = process.env.ST_ROOT || process.cwd();
      this.loadConfig();
      this.banned = {};
      this.clients = [];
      this.channels = {};
      this.pendingRestart = null;
      // set process title
      process.title = "synctube-server";
      if (this.opts.plugins) {
        ref = this.opts.plugins;
        for (i = 0, len = ref.length; i < len; i++) {
          plugin = ref[i];
          this.loadPlugin(plugin);
        }
      }
    }

    loadPlugin(plugin) {
      var err, ref;
      try {
        return plugin.setup(this, {
          Channel: Channel,
          Client: Client,
          Commands: Commands,
          HttpRequest: HttpRequest,
          COLORS: COLORS,
          UTIL: UTIL
        });
      } catch (error) {
        err = error;
        return this.error(`Failed to setup plugin ${(plugin != null ? (ref = plugin._module) != null ? ref.filename : void 0 : void 0)}: ${err}`);
      }
    }

    loadConfig() {
      if (!fs.existsSync(`${this.root}/config.js`)) {
        fs.copyFileSync(`${this.root}/config.example.js`, `${this.root}/config.js`);
        this.warn("No config file found! Copied config.example.js to config.js");
      }
      this.opts = require(`${this.root}/config.js`);
      if (!this.opts.systemPassword) {
        this.opts.systemPassword = require("crypto").randomBytes(10).toString("hex");
        this.warn("===========================================");
        this.warn("== No system password defined in config, ==");
        this.warn("== a random password will be generated!  ==");
        this.warn("== This will happen every boot, to avoid ==");
        this.warn("== this set a password in your config.js ==");
        this.warn(`== SystemPassword: ${this.opts.systemPassword}  ==`);
        return this.warn("===========================================");
      }
    }

    listen() {
      if (this.http) {
        throw "HTTP server is already bound!";
      }
      this.info("Creating HTTP server...");
      this.http = http.createServer((...a) => {
        return this.handleHTTPRequest(...a);
      });
      this.debug(`Binding HTTP/WS server on port ${this.opts.port}...`);
      this.http.listen(this.opts.port, this.opts.host);
      this.http.on("listening", () => {
        return this.info(`HTTP/WS server is listening on IPv${this.http._connectionKey}`);
      });
      // create WS socket server
      this.ws = new webSocketServer({
        httpServer: this.http
      });
      return this.ws.on("request", (request) => {
        return this.handleWSRequest(request);
      });
    }

    eachClient(method, ...args) {
      var c, i, len, ref, results;
      ref = this.clients;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        results.push(c != null ? typeof c[method] === "function" ? c[method](...args) : void 0 : void 0);
      }
      return results;
    }

    nullSession(client, forceReindex) {
      this.clients[client.index] = null;
      return this.cleanupSessions(forceReindex);
    }

    cleanupSessions(force = false) {
      var c, i, j, len, len1, newClients, nulled, ref, ref1;
      if (!force) {
        nulled = 0;
        ref = this.clients;
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          if (c === null) {
            nulled += 1;
          }
        }
        if (nulled >= this.opts.sessionReindex) {
          this.debug(`reindexing sessions (${nulled} nulled sessions)`);
        } else {
          return;
        }
      }
      newClients = [];
      ref1 = this.clients;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        c = ref1[j];
        if (c !== null) {
          newClients.push(c);
        }
      }
      this.clients = newClients;
      return this.eachClient("reindex");
    }

    handlePendingRestart(force = false, client) {
      var diff, fdiff, msg;
      if (this.pendingRestart == null) {
        clearTimeout(this.pendingRestartTimeout);
        return;
      }
      msg = this.pendingRestartReason;
      diff = (this.pendingRestart - (new Date).getTime()) / 1000;
      fdiff = UTIL.secondsToTimestamp(diff, false);
      if (diff <= 0) {
        if (client) {
          client.sendSystemMessage(`Server will restart NOW${(msg ? ` (${msg})` : "")}`);
        } else {
          this.eachClient("sendSystemMessage", `Server will restart NOW${(msg ? ` (${msg})` : "")}`);
        }
        throw "bye";
      } else {
        if (force || parseInt(diff % 15 * 60) === 0 || parseInt(diff % 5 * 60) === 0 || parseInt(diff % 60) === 0 || parseInt(diff) === 60 || parseInt(diff) === 30 || parseInt(diff) === 15 || parseInt(diff) <= 5) {
          if (client) {
            client.sendSystemMessage(`Server will restart in ${fdiff}${(msg ? ` (${msg})` : "")}`);
          } else {
            this.eachClient("sendSystemMessage", `Server will restart in ${fdiff}${(msg ? ` (${msg})` : "")}`);
          }
        }
        if (client) {
          return;
        }
        return this.pendingRestartTimeout = UTIL.delay(1000, () => {
          return this.handlePendingRestart();
        });
      }
    }

    handleHTTPRequest(request, response) {
      var req;
      req = new HttpRequest(this);
      if (this.opts.answerHttp) {
        return req.accept(request, response);
      } else {
        return req.reject(request, response);
      }
    }

    handleWSRequest(request) {
      var client;
      client = new Client(this);
      return client.accept(request).listen();
    }

    banIp(ip, duration, reason) {
      var client, end, i, len, ref, results;
      end = duration === -1 ? null : new Date((new Date).getTime() + duration * 1000);
      this.banned[ip] = end;
      ref = this.clients;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        client = ref[i];
        if (client != null) {
          results.push(this.guardBanned(client, reason));
        }
      }
      return results;
    }

    guardBanned(client, reason) {
      var match;
      if (!client) {
        return false;
      }
      if (!this.banned.hasOwnProperty(client.ip)) {
        return false;
      }
      match = this.banned[client.ip];
      // check expired
      if (match && (new Date) > match) {
        this.debug(`Purge expired ban for ${client.ip} which expired ${match}`);
        delete this.banned[client.ip];
        return false;
      }
      client.info(`closing connection for ${client.ip}, banned until ${match}`);
      client.sendCode("banned", {
        banned_until: match,
        reason: reason
      });
      client.sendSystemMessage(`You got banned from the server ${(match ? `until ${match}` : "permanently")}!`);
      if (reason) {
        client.sendSystemMessage(`Reason: ${reason}`);
      }
      client.connection.close();
      return true;
    }

    // ===========
    // = Logging =
    // ===========
    debug(...msg) {
      if (!this.opts.debug) {
        return;
      }
      msg.unshift(new Date);
      msg.unshift("[ST-DEBUG]");
      return console.debug.apply(this, msg);
    }

    info(...msg) {
      msg.unshift(new Date);
      msg.unshift("[ST-INFO] ");
      return console.log.apply(this, msg);
    }

    warn(...msg) {
      msg.unshift(new Date);
      msg.unshift("[ST-WARN] ");
      return console.warn.apply(this, msg);
    }

    error(...msg) {
      msg.unshift(new Date);
      msg.unshift("[ST-ERROR]");
      return console.error.apply(this, msg);
    }

  };

}).call(this);
