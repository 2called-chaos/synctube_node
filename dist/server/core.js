// Generated by CoffeeScript 2.3.2
(function() {
  // requires
  var COLORS, Channel, Client, HttpRequest, SyncTubeServer, UTIL, http, spawn, webSocketServer;

  http = require('http');

  webSocketServer = require('websocket').server;

  ({spawn} = require('child_process'));

  // colors
  COLORS = require("../colors.js");

  UTIL = require("./util.js");

  Channel = require("./channel.js").Class;

  Client = require("./client.js").Class;

  HttpRequest = require("./http_request.js").Class;

  exports.Class = SyncTubeServer = (function() {
    class SyncTubeServer {
      constructor(opts = {}) {
        var base, base1, base2, base3, base4, base5;
        this.opts = opts;
        // set process title
        process.title = 'synctube-server';
        if ((base = this.opts).debug == null) {
          base.debug = false;
        }
        if ((base1 = this.opts).port == null) {
          base1.port = 1337; // Don't forget to change in client as well
        }
        if ((base2 = this.opts).packetInterval == null) {
          base2.packetInterval = 2000; // (CL) interval in ms for CLIENTS to send packet updates to the server
        }
        if ((base3 = this.opts).maxDrift == null) {
          base3.maxDrift = 5000; // (CL) max ms (1000ms = 1s) for CLIENTS before force seeking to correct drift to host
        }
        if ((base4 = this.opts).answerHttp == null) {
          base4.answerHttp = true; // If set to false no static assets will be served, all requests result in a 400: Bad request
        }
        if ((base5 = this.opts).sessionReindex == null) {
          base5.sessionReindex = 250; // amount of nulled sessions before a reindexing occurs
        }
        this.clients = [];
        this.channels = {};
      }

      listen() {
        if (this.http) {
          throw "HTTP server is already bound!";
        }
        this.debug("Creating HTTP server...");
        this.http = http.createServer((...a) => {
          return this.handleHTTPRequest(...a);
        });
        this.debug(`Binding HTTP/WS server on port ${this.opts.port}...`);
        this.http.listen(this.opts.port, () => {
          return this.debug(`HTTP/WS server is listening on port ${this.opts.port}!`);
        });
        // create WS socket server
        this.ws = new webSocketServer({
          httpServer: this.http
        });
        return this.ws.on("request", (request) => {
          return this.handleWSRequest(request);
        });
      }

      eachClient(method, ...args) {
        var c, i, len, ref, results;
        ref = this.clients;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          results.push(typeof c[method] === "function" ? c[method](...args) : void 0);
        }
        return results;
      }

      nullSession(client, forceReindex) {
        this.clients[client.index] = null;
        return this.cleanupSessions(forceReindex);
      }

      cleanupSessions(force = false) {
        var c, i, j, len, len1, newClients, nulled, ref, ref1;
        if (!force) {
          nulled = 0;
          ref = this.clients;
          for (i = 0, len = ref.length; i < len; i++) {
            c = ref[i];
            if (c === null) {
              nulled += 1;
            }
          }
          if (nulled >= this.opts.sessionReindex) {
            this.debug(`reindexing sessions (${nulled} nulled sessions)`);
          } else {
            return;
          }
        }
        newClients = [];
        ref1 = this.clients;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          c = ref1[j];
          if (c !== null) {
            newClients.push(c);
          }
        }
        this.clients = newClients;
        return this.eachClient("reindex");
      }

      handleHTTPRequest(request, response) {
        var req;
        req = new HttpRequest(this);
        if (this.opts.answerHttp) {
          return req.accept(request, response);
        } else {
          return req.reject(request, response);
        }
      }

      handleWSRequest(request) {
        var client;
        client = new Client(this);
        return client.accept(request).listen();
      }

      // ===========
      // = Logging =
      // ===========
      debug(...msg) {
        if (!this.opts.debug) {
          return;
        }
        msg.unshift(new Date);
        msg.unshift("[ST]");
        return console.debug.apply(this, msg);
      }

      warn(...msg) {
        msg.unshift(new Date);
        msg.unshift("[ST]");
        return console.warn.apply(this, msg);
      }

      error(...msg) {
        msg.unshift(new Date);
        msg.unshift("[ST]");
        return console.error.apply(this, msg);
      }

      // ===================
      // = Server commands =
      // ===================
      handleMessage(client, message, msg) {
        var m;
        if (m = msg.match(/^!packet:(.+)$/i)) {
          return this.SCMD_packet(client, m[1]);
        }
        if (m = msg.match(/^\/join\s([^\s]+)$/i)) {
          return this.SCMD_join(client, m[1]);
        }
        if (m = msg.match(/^\/control(?:\s([^\s]+)(?:\s(.+))?)?$/i)) {
          return this.SCMD_control(client, m[1], m[2]);
        }
        if (msg.match(/^\/rename$/i)) {
          return this.SCMD_rename(client);
        }
        if (msg.match(/^\/restart$/i)) {
          return this.SCMD_restart(client);
        }
        if (m = msg.match(/^\/invoke\s([^\s]+)(?:\s(.+))?$/i)) {
          return this.SCMD_invoke(client, m[1], m[2]);
        }
        if (m = msg.match(/^\/dump\s([^\s]+)(?:\s(.+))?$/i)) {
          return this.SCMD_dump(client, m[1], m[2]);
        }
        return false;
      }

      SCMD_packet(client, jdata) {
        var ch, error, json, seek_was;
        try {
          json = JSON.parse(jdata);
        } catch (error1) {
          error = error1;
          this.error("Invalid JSON", jdata, error);
          return;
        }
        client.lastPacket = new Date;
        ch = client.subscribed;
        if (ch && (!client.state || (JSON.stringify(client.state) !== jdata))) {
          json.time = new Date;
          if ((json.seek != null) && (json.playtime != null)) {
            json.timestamp = UTIL.videoTimestamp(json.seek, json.playtime);
          }
          client.state = json;
          ch.broadcastCode(client, "update_single_subscriber", {
            channel: ch.name,
            data: ch.getSubscriberData(client, client, client.index)
          });
          if (client === ch.control[ch.host] && ch.desired.url === json.url) {
            seek_was = ch.desired.seek;
            ch.desired.seek = json.seek;
            ch.desired.seek_update = new Date();
            ch.broadcastCode(false, "desired", Object.assign({}, ch.desired, {
              force: Math.abs(ch.desired.seek - seek_was) > 2.75
            }));
          }
        } else {
          if (ch) {
            client.sendCode("desired", ch.desired);
          }
        }
        return true;
      }

      SCMD_join(client, chname) {
        var channel;
        if (channel = this.channels[chname]) {
          channel.subscribe(client);
        } else {
          client.sendSystemMessage("I don't know about this channel, sorry!");
          client.sendSystemMessage(`<small>You can create it with <strong>/control ${UTIL.htmlEntities(chname)} [password]</strong></small>`, COLORS.info);
        }
        return client.ack();
      }

      SCMD_control(client, name, password) {
        var channel, chname, ref;
        chname = UTIL.htmlEntities(name || ((ref = client.subscribed) != null ? ref.name : void 0) || "");
        if (!chname) {
          client.sendSystemMessage("Channel name required", COLORS.red);
          return client.ack();
        }
        if (channel = this.channels[chname]) {
          if (channel.control.indexOf(client) > -1 && password === "delete") {
            channel.destroy(client);
            return client.ack();
          } else {
            if (channel.password === password) {
              channel.subscribe(client);
              channel.grantControl(client);
            } else {
              client.sendSystemMessage("Password incorrect", COLORS.red);
            }
          }
        } else {
          this.channels[chname] = new Channel(this, chname, password);
          client.sendSystemMessage("Channel created!", COLORS.green);
          this.channels[chname].subscribe(client);
          this.channels[chname].grantControl(client);
        }
        return client.ack();
      }

      SCMD_rename(client) {
        client.sendCode("require_username", {
          autofill: false
        });
        client.old_name = client.name;
        client.name = null;
        client.sendSystemMessage("Tell me your new username!");
        return client.ack();
      }

      SCMD_restart(client) {
        client.sendSystemMessage("See ya!");
        throw "bye";
        //UTIL.delay 1000, => client.sendCode "navigate", reload: true
        return true;
      }

      SCMD_invoke(client, which, args) {
        args || (args = "{}");
        client.sendCode(which, JSON.parse(args));
        return client.ack();
      }

      SCMD_dump(client, what, detail) {
        if (what === "client") {
          console.log(detail ? this.clients[parseInt(detail)] : client);
        } else if (what === "channel") {
          console.log(detail ? this.channels[detail] : client.subscribed ? client.subscribed : this.channels);
        }
        return client.ack();
      }

    };

    // Clients can't use these names
    SyncTubeServer.prototype.PROTECTED_NAMES = ["admin", "system"];

    // Default video to cue in new channels
    SyncTubeServer.prototype.DEFAULT_CTYPE = "youtube"; // youtube, frame, image, video (mp4/webp)

    SyncTubeServer.prototype.DEFAULT_URL = "6Dh-RL__uN4"; // id suffices when YouTube

    SyncTubeServer.prototype.DEFAULT_AUTOPLAY = false; // only when youtube or video

    return SyncTubeServer;

  }).call(this);

}).call(this);
