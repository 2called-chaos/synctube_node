// Generated by CoffeeScript 2.3.2
(function() {
  // requires
  var COLORS, Channel, Client, SyncTubeServer, fs, http, spawn, webSocketServer;

  http = require('http');

  fs = require('fs');

  webSocketServer = require('websocket').server;

  ({spawn} = require('child_process'));

  // colors
  COLORS = require("../colors.js");

  Channel = require("./channel.js").Class;

  Client = require("./client.js").Class;

  exports.Class = SyncTubeServer = (function() {
    class SyncTubeServer {
      debug(...msg) {
        if (!this.opts.debug) {
          return;
        }
        msg.unshift(new Date);
        msg.unshift("[ST]");
        return console.debug.apply(this, msg);
      }

      warn(...msg) {
        msg.unshift(new Date);
        msg.unshift("[ST]");
        return console.warn.apply(this, msg);
      }

      error(...msg) {
        msg.unshift(new Date);
        msg.unshift("[ST]");
        return console.error.apply(this, msg);
      }

      constructor(opts = {}) {
        var base, base1, base2, base3;
        this.opts = opts;
        // set process title
        process.title = 'synctube-server';
        if ((base = this.opts).debug == null) {
          base.debug = false;
        }
        if ((base1 = this.opts).port == null) {
          base1.port = 1337; // Don't forget to change in client as well
        }
        if ((base2 = this.opts).packetInterval == null) {
          base2.packetInterval = 2000; // (CL) interval in ms for CLIENTS to send packet updates to the server
        }
        if ((base3 = this.opts).maxDrift == null) {
          base3.maxDrift = 5000; // (CL) max ms (1000ms = 1s) for CLIENTS before force seeking to correct drift to host
        }
        this.clients = [];
        this.channels = {};
      }

      listen() {
        if (this.http) {
          throw "HTTP server is already bound!";
        }
        this.debug("Creating HTTP server...");
        this.http = http.createServer((...a) => {
          return this.handleHTTPRequest(...a);
        });
        this.debug(`Binding HTTP/WS server on port ${this.opts.port}...`);
        this.http.listen(this.opts.port, () => {
          return this.debug(`HTTP/WS server is listening on port ${this.opts.port}!`);
        });
        // create WS socket server
        this.ws = new webSocketServer({
          httpServer: this.http
        });
        return this.ws.on("request", (request) => {
          return this.handleWSRequest(request);
        });
      }

      htmlEntities(str) {
        return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
      }

      delay(ms, func) {
        return setTimeout(func, ms);
      }

      eachClient(method, ...args) {
        var c, i, len, ref, results;
        ref = this.clients;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          results.push(typeof c[method] === "function" ? c[method](...args) : void 0);
        }
        return results;
      }

      handleHTTPRequest(request, response) {
        var file, type;
        if (this.SERVE_STATIC.indexOf(request.url) > -1) {
          file = request.url;
          if (file === "/") {
            file = "/index.html";
          }
          file = `.${file}`;
          type = "text/html";
          if (file.slice(-3) === ".js") {
            type = "application/javascript";
          }
          if (fs.existsSync(file)) {
            this.debug(`200: served ${file} (${type}) IP: ${request.connection.remoteAddress}`);
            response.writeHead(200, {
              'Content-Type': 'text/html'
            });
            return response.end(fs.readFileSync(file));
          } else {
            this.warn(`404: Not Found (${request.url}) IP: ${request.connection.remoteAddress}`);
            response.writeHead(404, {
              'Content-Type': 'text/plain'
            });
            return response.end("Error 404: Not Found");
          }
        } else {
          this.warn(`400: Bad Request (${request.url}) IP: ${request.connection.remoteAddress}`);
          response.writeHead(400, {
            'Content-Type': 'text/plain'
          });
          return response.end("Error 400: Bad Request");
        }
      }

      handleWSRequest(request) {
        var client;
        client = new Client(this);
        return client.accept(request).listen();
      }

      handleMessage(client, message, msg) {
        var m;
        if (m = msg.match(/^!packet:(.+)$/i)) {
          return this.SCMD_packet(client, m[1]);
        }
        if (m = msg.match(/^\/invoke\s([^\s]+)(?:\s(.+))?$/i)) {
          return this.SCMD_invoke(client, m[1], m[2]);
        }
        if (msg.match(/^\/rename$/i)) {
          return this.SCMD_rename(client);
        }
        if (m = msg.match(/^\/restart$/i)) {
          return this.SCMD_restart(client);
        }
        if (m = msg.match(/^\/retry$/i)) {
          return this.SCMD_retry(client);
        }
        if (m = msg.match(/^\/control(?:\s([^\s]+)(?:\s(.+))?)?$/i)) {
          return this.SCMD_control(client, m[1], m[2]);
        }
        if (m = msg.match(/^\/join\s([^\s]+)$/i)) {
          return this.SCMD_join(client, m[1]);
        }
        if (m = msg.match(/^\/leave$/i)) {
          return this.SCMD_leave(client);
        }
        return false;
      }

      SCMD_packet(client, jdata) {
        var ch, error, json, seek_was;
        try {
          json = JSON.parse(jdata);
        } catch (error1) {
          error = error1;
          this.error("Invalid JSON", jdata, error);
          return;
        }
        client.lastPacket = new Date;
        ch = client.subscribed;
        if (ch && (!client.state || (JSON.stringify(client.state) !== jdata))) {
          json.time = new Date;
          client.state = json;
          ch.broadcastCode(client, "update_single_subscriber", {
            channel: ch.name,
            data: ch.getSubscriberData(client, client, client.index)
          });
          if (client === ch.control[ch.host] && ch.desired.url === json.url) {
            seek_was = ch.desired.seek;
            ch.desired.seek = json.seek;
            ch.desired.seek_update = new Date();
            ch.broadcastCode(false, "desired", Object.assign({}, ch.desired, {
              force: Math.abs(ch.desired.seek - seek_was) > 2.75
            }));
          }
        } else {
          if (ch) {
            client.sendCode("desired", ch.desired);
          }
        }
        return true;
      }

      SCMD_invoke(client, which, args) {
        args || (args = "{}");
        client.sendCode(which, JSON.parse(args));
        client.ack();
        return true;
      }

      SCMD_rename(client) {
        client.sendCode("require_username", {
          autofill: false
        });
        client.old_name = client.name;
        client.name = null;
        client.sendSystemMessage("Tell me your new username!");
        client.ack();
        return true;
      }

      SCMD_restart(client) {
        client.sendSystemMessage("See ya!");
        throw "bye";
        //@delay 1000, => client.sendCode "navigate", reload: true
        return true;
      }

      SCMD_retry(client) {
        var ch;
        if (!(ch = client.subscribed)) {
          return;
        }
        ch.revokeControl(client);
        ch.unsubscribe(client);
        ch.subscribe(client);
        return client.ack();
      }

      SCMD_control(client, name, password) {
        var channel, chname, ref;
        chname = this.htmlEntities(name || ((ref = client.subscribed) != null ? ref.name : void 0) || "");
        if (!chname) {
          client.sendSystemMessage("Channel name required", COLORS.red);
          return client.ack();
        }
        if (channel = this.channels[chname]) {
          if (channel.control.indexOf(client) > -1 && password === "delete") {
            channel.destroy(client);
            return client.ack();
          } else {
            if (channel.password === password) {
              channel.subscribe(client);
              channel.grantControl(client);
            } else {
              client.sendSystemMessage("Password incorrect", COLORS.red);
            }
          }
        } else {
          this.channels[chname] = new Channel(this, chname, password);
          client.sendSystemMessage("Channel created!", COLORS.green);
          this.channels[chname].subscribe(client);
          this.channels[chname].grantControl(client);
        }
        return client.ack();
      }

      SCMD_join(client, chname) {
        var channel;
        if (channel = this.channels[chname]) {
          channel.subscribe(client);
        } else {
          client.sendSystemMessage("I don't know about this channel, sorry!");
          client.sendSystemMessage(`<small>You can create it with <strong>/control ${this.htmlEntities(chname)} [password]</strong></small>`, COLORS.info);
        }
        return client.ack();
      }

      SCMD_leave(client) {
        var ch;
        if (ch = client.subscribed) {
          ch.unsubscribe(client);
          client.sendCode("video_action", {
            action: "destroy"
          });
        } else {
          client.sendSystemMessage("You are not in any channel!");
        }
        return client.ack();
      }

    };

    SyncTubeServer.prototype.SERVE_STATIC = ["/", "/favicon.ico", "/dist/client.js"];

    SyncTubeServer.prototype.PROTECTED_NAMES = ["admin", "system"];

    SyncTubeServer.prototype.DEFAULT_VIDEO = "6Dh-RL__uN4";

    SyncTubeServer.prototype.DEFAULT_AUTOPLAY = false;

    return SyncTubeServer;

  }).call(this);

}).call(this);
